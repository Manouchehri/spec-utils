#!/usr/bin/env perl

use utf8;

use feature qw(say);

use strict;
use warnings;
use re '/aa';

use File::Spec::Functions qw(catfile catdir);
use File::Slurp qw(read_file);
use Getopt::Long qw(:config gnu_getopt);
use FindBin;
use lib catdir $FindBin::Bin, 'lib';

use Local::Kernel::Common qw(check_kernel_files_readable autodetect_kernel_directory);

use constant CAPABILITY_C => catfile('security', 'capability.c');

my $kdir;
my $verbose = 0;
my $caller_lev = 2;
my $caller_set = 0;
my $trace_functions = 0;
my $trace_syscalls = 1;

GetOptions(
   'kdir|k=s'     => sub { if (check_kernel_files_readable($_[1], CAPABILITY_C)) { $kdir = $_[1] } else { die('Incorrect path to kernel (required files ' . CAPABILITY_C . "): '$_[1]'\n") } },
   'verbose|v+'   => \$verbose,
   'caller|c'     => sub { unless ($caller_set) { $caller_set = 1; $caller_lev = 1 } else { ++$caller_lev } },
   'syscalls|s!'  => \$trace_syscalls,
   'functions|f!' => \$trace_functions
) or die "Incorrect usage!\n";

$kdir //= autodetect_kernel_directory(files => [CAPABILITY_C]);

die "Can't find path to linux kernel sources directory (required files " . CAPABILITY_C . ").\n"
   unless $kdir;

sub generate_caller_func
{
   my $level  = $_[0];
   my $ret_header = qq!function caller:string() {\n\treturn sprintf(!;
   my $ret_footer = qq!)\n}\n!;

   my $printf_string = '';
   my $printf_arguments = '';


   for (my $i = 1; $i <= $level; ++$i) {
      $printf_string .= '->%s';
      $printf_arguments .= ", symname(stack($i))";
   }
   return $ret_header . qq("$printf_string") . $printf_arguments . $ret_footer;
}

my %configuration;

my $security_c = read_file(catfile($kdir, CAPABILITY_C));

if ($security_c =~ m/security_fixup_ops\s*\(\s*struct\s+security_operations\s*\*ops\s*\)\s*\{([^}]+)\}/m) {
	my $contents = $1;
	while ($contents =~ s/#ifdef\s+(?<conf>\w+)\s+(?<funcs>[^\#]+)\s*#endif//m) {
		my $conf = $+{conf};
		$configuration{ $conf } = [ map { "cap_$_" } ($+{funcs} =~ m/set_to_cap_if_null\s*\(\s*\w+\s*,\s*(\w+)\s*\);/g)];
	}
	$configuration{'DEFAULT'} = [ map { "cap_$_" } ($contents =~ m/set_to_cap_if_null\s*\(\s*\w+\s*,\s*(\w+)\s*\);/g)];
} else {
	die("Can't find security_fixup_ops.\n");
}

my $global = <<'GLOBAL';
global in_syscall

probe begin {
   in_syscall = 0
}
GLOBAL


my $params;

if ($verbose == 0) {
   $params = '$$parms';
} elsif ($verbose == 1) {
   $params = '$$parms$'
} else {
   $params = '$$parms$$'
}

my $callback_macro = <<CBM;
\@define log(fname) %(
\tif ( pid() == target() ) {
\t\tprefix = ""
\t\tif (in_syscall) {
\t\t\tfor(i = 0; i < in_syscall; ++i)
\t\t\t\tprefix .= "\\t"
\t\t} else {
\t\t\tprefix .= "* "
\t\t}
\t\tprintf("%s%s: %s %d %s params: %s\\n", prefix, \@fname, execname(), pid(), caller(), $params)
\t}
%)
CBM

my $header =   "\n" .
               $global . "\n\n" .
               generate_caller_func($caller_lev) . "\n" .
               $callback_macro;


my $body = '';

foreach (keys %configuration) {
   my $acc = "probe";

   foreach (@{ $configuration{$_} }) {
      $acc .= qq!\tkernel.function("${_}"),\n!;
   }
   $acc =~ s/,(?=\n$)//;

   $acc .= qq!{\n\t\@log(ppfunc())\n}\n\n!;

   if ($_ =~ m/^CONFIG_/) {
      $acc = qq!%( $_ == "y" %?\n! . ($acc =~ s/^/\t/mgr);
      $acc .= "%)\n\n";
   }

   $body .= $acc;
}


my $syscall_probe = <<PROBE;
probe syscall.* {
\tif (pid() == target()) {
\t\tprefix = ""
\t\tif (in_syscall) {
\t\t\tfor(i = 0; i < in_syscall; ++i)
\t\t\t\tprefix .= "\\t"
\t\t} else {
\t\t\tprefix .= "\\n"
\t\t}
\t\tprintf("%s<syscall %s: %s(%s)\\n", prefix, execname(), name, argstr)
\t\tin_syscall++
\t}
}
PROBE

my $syscall_return_probe = <<PROBE;
probe syscall.*.return {
\tif (pid() == target()) {
\t\tin_syscall--
\t\tprefix = ""
\t\tsuffix = ""
\t\tif (in_syscall) {
\t\t\tfor(i = 0; i < in_syscall; ++i)
\t\t\t\tprefix .= "\\t"
\t\t} else {
\t\t\tsuffix .= "\\n"
\t\t}
\t\tprintf("%s>syscall ret %s: %s result: %s%s\\n", prefix, execname(), name, retstr, suffix)
\t}
}
PROBE

my $process_functions = <<PROBE;
probe process.function("*") {
\tif (pid() == target()) {
\t\tprintf("<<function %s: %s\\n", execname(), ppfunc())
\t}
}
PROBE

my $process_functions_return = <<PROBE;
probe process.function("*").return {
\tif (pid() == target()) {
\t\tprintf(">>function ret %s: %s\\n", execname(), ppfunc())
\t}
}
PROBE

my $footer = '';

$footer .= ($syscall_probe . "\n" . $syscall_return_probe . "\n")           if $trace_syscalls;
$footer .= ($process_functions .	"\n" . $process_functions_return . "\n")   if $trace_functions;


#print $header . "\n\n" . $body . "\n\n" . $footer;
print $header . "\n\n" . $body . "\n" . $footer;

