#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say);
use re '/aa';

use utf8::all;
use Env qw(CURRENT_KERNEL CURRENT_PROJECT);
use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Text::ANSITable;
use Class::CSV;

use FindBin;
use lib "$FindBin::Bin/lib";

use Local::C::Transformation;
use Local::String::Utils qw(normalize);


my $kfile = 'include/linux/security.h';
my $pfile = 'sec-hooks.c';

my $kdir = '';
my $pdir = '';

my $output = '';
my $csvout = 0;

GetOptions(
   'kdir|k=s'      => sub { if ( -f "$_[1]/Kbuild" && -r "$_[1]/$kfile" ) { $kdir = $_[1] } else { die(qq(Incorrect path to kernel: "$_[1]"\n)) } },
   'parsec|p=s'    => \$pdir,
   'file|f=s'      => \$pfile,
   'output|o=s'    => \$output,
   'csv-output|c!' => \$csvout,
) or die "Incorrect usage!\n";

die(qq(Incorrect path to parsec: "$pdir"\n)) if $pdir && !( -d $pdir && -r "$pdir/$pfile" );


unless ($kdir) {
   if ( -r $kfile) {
      $kdir = '.';
   } elsif ( -r "$CURRENT_KERNEL/$kfile" ) {
      $kdir = $CURRENT_KERNEL;
   }
}

die "Can't find path to linux kernel sources directory.\n" unless $kdir;

unless ($pdir) {
   if ( -r $pfile) {
      $pdir = '.';
   } elsif ( -r "$CURRENT_PROJECT/$pfile" ) {
      $pdir = $CURRENT_PROJECT;
   }
}

die "Can't find path to parsec sources directory.\n" unless $pdir;


open MAKEFILE, "< $kdir/Makefile";
my @kver = map { <MAKEFILE> =~ m/=\s*(\d+)/ } (1 .. 3);
my $kernel_version = join('.', @kver);
close MAKEFILE;

my $sec_file = read_file("$kdir/$kfile");
my $hooks_file = read_file("$pdir/$pfile");

adapt($sec_file, comments => 1);
adapt($hooks_file, comments => 1);

sub argname {
   $_[0] =~ m/(\w+)$/;
   return $1 ne 'void' ? $1 : '';
}

sub argtype {
   $_[0] =~ m/^(.*?)(?=\s*\w+$)/;
   return $1 eq '' ? 'void' : $1;
}

sub parse_structure_defition_ops_fields {
   my $conf = $_[1];
   map { normalize($_); if (m/\.(\w+)\s*=\s*(\w+)/) {$1 => +{ init => $2, conf => $conf }} else { () } } split /,/, $_[0];
}

sub parse_structure_declaration_ops_fields {
   my $conf = $_[1];
   my @fields = map normalize($_), split(/;/, $_[0]);

   # filter non-functions
   @fields = grep { m/\(\*\w+\)\s*\(/ } @fields;

   map { m/\(\*(\w+)\)\s*\((.*?)\)$/; $1 => +{ args => $2, conf => $conf } } @fields;
}

sub parse_security_operations_structure {
   my $handler = $_[1];
   my %structure;

   if ($_[0] =~ m/struct\s+security_operations(?:\s+\w+\s*=)?\s*(?<br>\{(?:(?>[^\{\}]+)|(?&br))+\})/m) {
      my @lines = split /\n/, $1;
      my $buf = '';
      my @ifdefs;
      my %preprocessed;

      foreach (@lines) {
         next if $_ =~ m/^\s*\n$/;
         if ($_ =~ m/^\s*\#\s*if\s+(?<cond>.+)$/) {
            %structure = (%structure, $handler->($buf, join( ' && ', @ifdefs)));
            $buf = '';
            push @ifdefs, normalize($+{cond});
            next;
         }
         if ($_ =~ m/^\s*\#\s*ifdef\s+(?<cond>\w+)\s*$/) {
            %structure = (%structure, $handler->($buf, join( ' && ', @ifdefs)));
            $buf = '';
            push @ifdefs, normalize($+{cond});
            next;
         }
         if ($_ =~ m/^\s*\#\s*ifndef\s+(?<cond>\w+)\s*$/) {
            %structure = (%structure, $handler->($buf, join( ' && ', @ifdefs)));
            $buf = '';
            push @ifdefs, '! ' . normalize($+{cond});
            next;
         }
         if ($_ =~ m/^\s*\#\s*else/) {
            %structure = (%structure, $handler->($buf, join( ' && ', @ifdefs)));
            $buf = '';
            push @ifdefs, '! ' . pop(@ifdefs);
            next;
         }
         if ($_ =~ m/^\s*\#\s*endif/) {
            %structure = (%structure, $handler->($buf, join( ' && ', @ifdefs)));
            $buf = '';
            pop @ifdefs;
            next;
         }
         $buf .= $_ . "\n";
      }
      die("Preprocessing error @ifdefs.") if scalar @ifdefs ne 0;
   } else {
      die("Can't find security_operations definition/declaration.\n");
   }

   return %structure;
}

my %str_kernel = parse_security_operations_structure $sec_file, \&parse_structure_declaration_ops_fields;
my %str_parsec = parse_security_operations_structure $hooks_file, \&parse_structure_defition_ops_fields;


foreach (keys %str_kernel) {
   if (defined $str_parsec{$_}) {
      $str_kernel{$_}{parsec} = $str_parsec{$_};
      delete $str_parsec{$_};
   }
}


my $columns = ['Idx', 'Указатель на функцию', 'Аргументы', 'Функция parsec', 'Конфигурация ядра', 'Конфигурация parsec'];
my $obj;
my $addfunc;
my $retfunc;

unless ($csvout) {
   my $t1 = Text::ANSITable->new;
   $t1->border_style('Default::bold');
   if ( -t STDOUT && !$output ) {
      $t1->color_theme('Default::default_gradation');
   } else {
      $t1->color_theme('Default::no_color');
   }

   $t1->columns($columns);

   $t1->set_column_style('Idx',                  pad  => 0);
   $t1->set_column_style('Указатель на функцию', align  => 'left');
   $t1->set_column_style('Аргументы',            align  => 'middle');
   $t1->set_column_style('Функция parsec',       align  => 'middle');
   $t1->set_column_style('Конфигурация ядра',    align  => 'middle');
   $t1->set_column_style('Конфигурация parsec',  align  => 'middle');

   #$t1->column_filter(sub { $_ ne'Аргументы' });
   $obj = \$t1;
   $addfunc = sub { Text::ANSITable::add_row($_[0], $_[1]); Text::ANSITable::add_row_separator($_[0], $_[1]); };
   $retfunc = sub { $_[0] . "\n" .  Text::ANSITable::draw($_[1]); };
} else {
   my $csv = Class::CSV->new(
      fields         => $columns,
      line_separator => "\r\n",
      csv_xs_options => {
         sep_char          => ';',
      },
   );

   $obj = \$csv;
   $addfunc = \&Class::CSV::add_line;
   $retfunc = sub { $_[0] . "\r\n" . join(';', map { '"' . $_ . '"' } @$columns) . "\r\n" . Class::CSV::string($_[1]); };
}


my $counter = 1;

foreach (reverse sort {defined $str_kernel{$a}{parsec} <=> defined $str_kernel{$b}{parsec}} keys %str_kernel) {
   my $init  = defined $str_kernel{$_}{parsec} ? $str_kernel{$_}{parsec}{init} : undef;
   my $args  = $str_kernel{$_}{args};
   my $kconf = $str_kernel{$_}{conf};
   my $pconf = defined $str_kernel{$_}{parsec} ? $str_kernel{$_}{parsec}{conf} : undef;
   my $line = [$counter++, $_, $args, $init, $kconf, $pconf];
   $addfunc->($$obj, $line)
}


my $str = $retfunc->(qq("Таблица функций в security_operations (версия ядра $kernel_version)"), $$obj);
if ($output) {
   write_file($output, { binmode => ':utf8' }, $str);
} else {
   print $str;
}

if (keys %str_parsec) {
   $columns = ['Idx', 'Указатель на функцию', 'Функция parsec', 'Конфигурация parsec'];

   #TODO: добавить аргументы
   unless ($csvout) {
      my $t2 = Text::ANSITable->new;
      $t2->border_style('Default::bold');
      if ( -t STDOUT && !$output ) {
         $t2->color_theme('Default::default_gradation');
      } else {
         $t2->color_theme('Default::no_color');
      }


      $t2->columns($columns);

      $t2->set_column_style('Idx',                  pad  => 0);
      $t2->set_column_style('Указатель на функцию', align  => 'left');
      $t2->set_column_style('Функция parsec',       align  => 'middle');
      $t2->set_column_style('Конфигурация parsec',  align  => 'middle');

      $obj = \$t2;
   } else {
      my $csv = Class::CSV->new(
         fields         => $columns,
         line_separator => "\r\n",
         csv_xs_options => {
            sep_char          => ';',
         },
      );

      $obj = \$csv;
   }


   $counter = 1;

   foreach (keys %str_parsec) {
      my $init  = $str_parsec{$_}{init};
      my $pconf = $str_parsec{$_}{conf};
      my $line = [$counter++, $_, $init, $pconf];

      $addfunc->($$obj, $line);
   }

   $str = "\r\n" . $retfunc->(qq("Таблица функций, отсутствующих в security_operations (версия ядра $kernel_version)"), $$obj);
   if ($output) {
      write_file($output, { binmode => ':utf8', append => 1 }, $str);
   } else {
      print "\r\n" . $str;
   }
}

