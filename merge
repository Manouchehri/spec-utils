#!/usr/bin/env perl

use warnings;
use strict;

use re '/aa';
use feature qw(say);

use lib::abs 'lib';

use utf8;

use RE::Common qw($varname);
use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Pod::Usage;
use Term::ANSIColor qw(:constants);
use File::Temp qw(tempfile);
use Algorithm::Diff qw(traverse_sequences);

use Local::String::Utils qw(trim is_blank ne_spaces normalize);
use Local::List::Utils qw(str_to_list);
use Local::Terminal qw(window_size);
use Local::C::Transformation qw(adapt restore remove remove_dup restore_macro restore_comments :RE :TYPES);
use Local::GCC::Preprocess qw(preprocess_directives);
use Local::File::Merge qw(merge);
use Local::File::C::Merge qw(merge_all_files_simple find_all_files);
use ACSL::Common qw(is_acsl_spec);

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}


=encoding utf8

=pod

=head1 merge

merge - Переложение спецификаций с одной версии исходного кода на другую.

=head1 SYNOPSIS

 merge [options]
 Options:
  -f|--from dir      - откуда переносятся спецификации
  -t|--to dir        - куда переносятся спецификации
  -s|--[no-]strict   - осуществлять дополнительные проверки при сопоставлении функций
  -k|--[no-]kdiff    - использовать kdiff3 вместо meld
  -h|--help          - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-f|--from dir>

Указание на директорию, откуда переносятся спецификации. По умолчанию - текущая директория.

=item B<-t|--to dir>

Указание на директорию, куда переносятся спецификации. По умолчанию директория берётся из переменной окружения CURRENT_PROJECT.

=item B<-s|--[no-]strict>

Осуществлять точное сопоставление по аргументам и возвращаемому результату функций или отключить эти проверки. По умолчанию проверки включены.

=item B<-k|--[no-]kdiff>

Когда программа не в состоянии автоматически переместить спецификации, вызывается внешний инструмент. По умолчанию это программа meld. Опция включает использование программы kdiff3 вместо meld.

=item B<-h|--help>

Выводит данное сообщение.

=back

=head1 DESCRIPTION

Программа считывает спецификации из всех *.[ch] файлов директории --from и её поддиректорий. После пошагово переносит спецификации, прикреплённые к конкретным функциям на эти же функции из файлов директории --to и её поддиректорий. Какая функция в каком конкретном файле располагается не имеет значения. Старые спецификации, если они были, заменяются новыми. Для того, чтобы программа считала спецификацию прикреплённой к функции, необходимо чтобы последняя распологалась перед B<определением> функции. Если несколько спецификаций расположено подряд, то все они считаются прикреплёнными к одной функции.

Если программа не смогла найти функцию, для которой написаны спецификации, то выводится сообщение об ошибке. Работа программы при этом продолжается.

Обычные комментарии к функциям не переносятся. Комментарии внутри спецификаций переносятся.

На последнем этапе функционирования программа выводит в STDERR все спецификации, которые не были перенесены. Чаще всего это спецификации, которые прикреплены не к функциям.

=cut


my $help = 0;
# '' need for -d checking
my $module_dir = $ENV{CURRENT_PROJECT} // '';
my $specs_dir = '.';
my $strict = 1;
my $kdiff = 0;
my $tr_wh = 0;

GetOptions(
   'from|f=s'     =>  \$specs_dir,
   'to|t=s'       =>  \$module_dir,
   'strict|s!'    =>  \$strict,
   'kdiff|k!'     =>  \$kdiff,
   'rtw|r!'       =>  \$tr_wh, # remove trailing whitespaces
   'help|h'       =>  \$help,
) or pod2usage(1);

pod2usage({-verbose => 2, -exitval => 0}) if $help;
pod2usage({-msg => "Wrong arguments.\n", -exitval => 2 }) unless -d $module_dir && -d $specs_dir;


#Global variables from Local::C::Transformation
my $comment_re = $comment_t{pattern};
my $macro_re   = $macro_t{pattern};


sub call_meld
{
   return 1 if $#_ > 2;

   my @template = map {$_ . 'XXXX'} qw/to_ from_ merge_/;
   my @f;
   foreach my $i (0 .. $#_) {
      my (undef, $name) = tempfile(TEMPLATE => $template[$i], SUFFIX => '.c');
      push @f, $name;

      write_file($name, @{$_[$i]})
   }

   my $ret;
   if ($kdiff) {
      $ret = system('kdiff3', @f)
   } else {
      $ret = system('meld', @f)
   }

   @{$_[-1]} = read_file($f[-1])
      unless $ret;

   unlink $f[$_] for 0 .. $#_;

   $ret
}

# dir
# returns hash ref
sub fetch_module_sources
{
   my @module  = find_all_files($_[0]);

   return {}
      unless @module;

   my %module;
   foreach my $f (@module) {
      $module{$f}{code} = read_file($f);
      adapt($module{$f}{code},
            comments => \@{ $module{$f}{c} },
            macro    => \@{ $module{$f}{m} }
      );

      my %i;
      foreach (0 .. $#{ $module{$f}{c} }) {
         $i{$_} = 1 if is_acsl_spec(@{ $module{$f}{c} }[$_])
      }
      $module{$f}{i} = \%i;
   }

   %module
}

sub fetch_specifications
{
   my $code = merge_all_files_simple($_[0]);

   return {}
      unless $code;

   adapt($code,
         comments => \my @comments,
         macro    => \my @macro
   );

   (
      specs    => \$code,
      comments => \@comments,
      macro    => \@macro
   )
}

sub contains_specs
{
   if ($_[0]) {
      while ($_[0] =~ m/$comment_re/g) {
         return 1
            if exists $_[1]->{$1}
      }
   }

   0
}

sub move_specs
{
   my ($fret, $spec, $file, $module, $sbegin, $send) = @_;

   my @interval;
   my $continue = 0;
   my ($cb, $ce) = (0, 0);

   while ($fret =~ m/$comment_t{pattern}/g) {
      my ($b, $e) = ($-[0], $+[0]);
      if (exists $module->{$file}{i}{$1}) {
         if ($continue) {
            $ce = $e + 1;
         } else {
            $cb = $b;
            $ce = $e + 1;
         }

         $continue = 1;
      } else {
         push @interval, ($cb, $ce);
         $continue = 0;
      }
   }
   push @interval, ($cb, $ce);

   while (@interval) {
      $ce = pop @interval;
      $cb = pop @interval;
      substr($fret, $cb, $ce - $cb, '');
   }
   $fret =~ s/\b(?=[a-zA-Z_])/$spec/;

   substr($module->{$file}{code}, $sbegin, $send - $sbegin, $fret);
}


### Fetching specifications from dir: $specs_dir
my %specs = fetch_specifications($specs_dir);
die(RED . "Can't find specifications sources." . RESET . "\n")
   unless %specs;

### Fetching module sources from dir: $module_dir
my %module = fetch_module_sources($module_dir);
die(RED . "Can't find module sources." . RESET . "\n")
   unless %module;

$specs{specs} = \((preprocess_directives($specs{specs}))[1]->{'<stdin>'});

my @comments = @{ $specs{comments} };
my @macro    = @{ $specs{macro}    };
my $code     = ${ $specs{specs}    };


my %acsl_specs;
### detecting specifications
foreach(0 .. $#comments) {
   if (is_acsl_spec($comments[$_])) {
      $acsl_specs{$_} = 1;
      $comments[$_] =~ s/\s+$//mg
         if $tr_wh;
   }
}


my $ret  = qr/(?<ret>[\w$Local::C::Transformation::special_symbols][\w\s\*$Local::C::Transformation::special_symbols]+)/;
my $name = qr/(?<name>$varname)/;
my $args = qr'(?>(?<args>\((?:(?>[^\(\)]+)|(?&args))*\)))';
my $body = qr'(?>(?<body>\{(?:(?>[^\{\}]+)|(?&body))*\}))';

my %s;
while ($code =~ m/$ret${s}*+\b$name${s}*+$args${s}*+(?:$body|;)/g) {
   my $name = $+{name};
   if (exists $s{$name} && defined $s{$name}{body}) {
      warn "Function $+{name} has been already defined.\n"
   } else {
      $s{$name}{ret}  = $+{ret};
      $s{$name}{args} = $+{args};

      $s{$name}{body} = $+{body}
         if exists $+{body};
   }
}

my %m;
foreach (keys %module) {
   while ($module{$_}{code} =~ m/$ret${s}*+\b$name${s}*+$args${s}*+$body/g) {
      my $name = $+{name};
      if (exists $m{$name}) {
         warn "Function $+{name} has been already defined.\n"
      } else {
         $m{$name}{file} = $_;

         $m{$name}{ret_idx}  = [$-[1], $+[1]];
         $m{$name}{body_idx} = [$-[4], $+[4]];

         $m{$name}{ret}  = $+{ret};
         $m{$name}{args} = $+{args};
         $m{$name}{body} = $+{body};
      }
   }
}


foreach (keys %s) {
   if ($s{$_}{ret} =~ m/($comment_re(\s*+$comment_re)*+).*\Z/s) {
      my $cs = $s{$_};
      my $spec = $1;
      my @exclude_specs;

      $spec =~ s/$comment_re/if (exists $acsl_specs{$1}) {push @exclude_specs, $1; "$comments[$1]"} else {''}/eg;
      next
         if is_blank $spec;
      $spec = trim $spec;
      $spec .= "\n";

      if (exists $m{$_}) {
         my $cm = $m{$_};
         my $file = $cm->{file};

         #additional checks
         if ($strict) {
            if (ne_spaces(remove_dup($cs->{args}), remove_dup($cm->{args}))) {
               warn "$cm->{file}: " . RED . 'arguments' . RESET . " of function " . GREEN . $_ . RESET . " doesn't match.\n";
               next
            }

            if (ne_spaces(remove_dup($cs->{ret}), remove_dup($cm->{ret}))) {
               warn "$cm->{file}: " . RED . 'return type' . RESET . " of function " . GREEN . $_ . RESET . " doesn't match.\n";
               next
            }
         }

         if (contains_specs $cs->{body}, \%acsl_specs) {
            my $fbody_saved = $cs->{body};
            my @exclude_specs;
            my @intervals;

            restore_macro($cs->{body}, \@macro);
# This code remove simple comments from new_code. Not very useful.
#            while ($cs->{body} =~ m/^[ \t]*$comment_re(?:[ \t]*+|$comment_re)*\n/gmp){
#               my ($b, $e) = ($-[0], $+[0]);
#               my @m = ${^MATCH} =~ m/$comment_re/g;
#               my $cond = 0;
#
#               foreach (@m) {
#                  $cond = 1 if exists $acsl_specs{$_}
#               }
#               unless ($cond) {
#                  push @intervals, ($b, $e)
#               }
#            }
#            while (@intervals) {
#               my $e = pop @intervals;
#               my $b = pop @intervals;
#               substr($cs->{body}, $b, $e - $b, '');
#            }
            $cs->{body} =~ s/$comment_re/if (exists $acsl_specs{$1}) {${^MATCH}} else {$comments[$1]}/egp;

            restore_macro($cm->{body}, $module{$file}{m});
            $cm->{body} =~ s/$comment_re/if (exists $module{$file}{i}{$1}) {${^MATCH}} else {$module{$file}{c}->[$1]}/egp;

            my $new_code = str_to_list $cs->{body};
            my $old_code = str_to_list $cm->{body};
            my @code;

            my $cant_resolve = 0;

            traverse_sequences(
               $old_code,
               $new_code,
               {
                  MATCH     => sub { push @code, @$new_code[$_[1]] },
                  DISCARD_A => sub { push @code, @$old_code[$_[0]] },
                  DISCARD_B => sub {
                     if (@$new_code[$_[1]] =~ m/^(?:\s++|$comment_re)*$/) {
                        push @code, @$new_code[$_[1]];
                     } elsif (@$new_code[$_[1]] =~ m/$comment_re/) {
                        $cant_resolve = 1;
                        push @code, @$new_code[$_[1]];
                     } else {
                        $cant_resolve = 1;
                     }
                  }
               },
               sub { $_[0] =~ s/\s++|$comment_re//gr }
            );

            $code = str_to_list(join('', @code) =~ s/$comment_re/push @exclude_specs, $1;$comments[$1]/ger);

            if ($cant_resolve) {
               my $function = $cm->{ret} . ' ' . $_ . $cm->{args};
               remove($function);
               $function = normalize($function) . "\n";

               $old_code = str_to_list(restore_comments(join('', @$old_code), $module{$_}{c}));
               $new_code = str_to_list(restore_comments($fbody_saved, \@comments));

               unshift $old_code, $function;
               unshift $new_code, $function;
               unshift $code,     $function;

               if (call_meld($old_code, $new_code, $code)) {
                  warn "Problems calling " . RED . ($kdiff ? 'kdiff3' : 'meld') . RESET .
                     ". Note, that changes in function '" . GREEN . $_ . RESET . "' will be merged anyway.\n"
               }

               shift $old_code;
               shift $new_code;
               my $check = shift $code;
               warn "Changes in string '" . GREEN . substr($check, 0, -1) . RESET . "' will not be merged.\n"
                  if $check ne $function;
            }

            delete $acsl_specs{$_} foreach @exclude_specs;
            substr($module{$file}{code}, $cm->{body_idx}[0], $cm->{body_idx}[1] - $cm->{body_idx}[0], join('', @$code));
         }

         move_specs($cm->{ret}, $spec, $file, \%module, @{$cm->{ret_idx}});
      }
      delete $acsl_specs{$_} foreach @exclude_specs
   }
}


foreach my $f (keys %module) {
   restore($module{$f}{code}, comments => $module{$f}{c}, macro => $module{$f}{m});
   write_file($f, $module{$f}{code});
}


if (keys %acsl_specs) {
   my (undef, $col) = window_size();

   warn RED, "Can't merge following specifications:" . RESET . "\n\n";
   warn join("\n" . BLUE . '-' x $col . RESET, map { $comments[$_] } sort keys %acsl_specs) . "\n";
}

