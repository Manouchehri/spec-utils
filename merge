#!/usr/bin/env perl

use warnings;
use strict;

use re '/aa';
use feature qw(say);

use lib::abs 'lib';

use utf8;

use RE::Common qw($varname);
use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Pod::Usage;
use Term::ANSIColor qw(:constants);
use File::Temp qw(tempfile);
use Algorithm::Diff qw(traverse_sequences);

use Local::String::Utils qw(trim);
use Local::Terminal qw(window_size);
use Local::C::Transformation qw(adapt restore :RE :TYPES);
use Local::File::Merge qw(merge);
use Local::File::C::Merge qw(merge_all_files_simple find_all_files);
use ACSL::Common qw(is_acsl_spec);

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}


=encoding utf8

=pod

=head1 merge

merge - Переложение спецификаций с одной версии исходного кода на другую.

=head1 SYNOPSIS

 merge [options]
 Options:
  -f|--from dir      - откуда переносятся спецификации
  -t|--to dir        - куда переносятся спецификации
  -d|--[no-]detailed - переключение режимов переноса спецификаций внутри тел функций
  -s|--[no-]strict   - осуществлять дополнительные проверки при сопоставлении функций
  -k|--[no-]kdiff    - использовать kdiff3 вместо meld
  -h|--help          - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-f|--from dir>

Указание на директорию, откуда переносятся спецификации. По умолчанию - текущая директория.

=item B<-t|--to dir>

Указание на директорию, куда переносятся спецификации. По умолчанию директория берётся из переменной окружения CURRENT_PROJECT.

=item B<-d|--[no-]detailed>

Если режим включён, то спецификации внутри тела функции переносятся по отдельности через привязки к строкам. В противном случае, если в теле функции есть хотя бы одна спецификация, то заменяется всё тело функции. Соответственно, в данным случае переносятся также и все изменения в коде, если таковые наличествуют. По умолчанию включён режим детального переноса, то есть посредством копирования отдельных спецификаций внутри тела функции.

=item B<-s|--[no-]strict>

Осуществлять точное сопоставление по аргументам и возвращаемому результату функций или отключить эти проверки. По умолчанию проверки включены.

=item B<-k|--[no-]kdiff>

Когда программа не в состоянии автоматически переместить спецификации, вызывается внешний инструмент. По умолчанию это программа meld. Опция включает использование программы kdiff3 вместо meld.

=item B<-h|--help>

Выводит данное сообщение.

=back

=head1 DESCRIPTION

Программа считывает спецификации из всех *.[ch] файлов директории --from и её поддиректорий. После пошагово переносит спецификации, прикреплённые к конкретным функциям на эти же функции из файлов директории --to и её поддиректорий. Какая функция в каком конкретном файле располагается не имеет значения. Старые спецификации, если они были, заменяются новыми. Для того, чтобы программа считала спецификацию прикреплённой к функции, необходимо чтобы последняя распологалась перед B<определением> функции. Если несколько спецификаций расположено подряд, то все они считаются прикреплёнными к одной функции.

Если программа не смогла найти функцию, для которой написаны спецификации, то выводится сообщение об ошибке. Работа программы при этом продолжается.

Обычные комментарии к функциям не переносятся. Комментарии внутри спецификаций переносятся.

На последнем этапе функционирования программа выводит в STDERR все спецификации, которые не были перенесены. Чаще всего это спецификации, которые прикреплены не к функциям.

=head1 BUGS

Программа не осуществляет никакого препроцессирования, за исключением обработки "#if 0" в исходниках из директории со спецификациями. Необходимость этого выглядит сомнительной. Однако, в ряде случаев это может приводить к переносу спецификаций, которые программистом считались скрытыми от таких инструментов, как Frama-C.

=cut

my $help = 0;
my $module_dir = $ENV{CURRENT_PROJECT} // '';
my $specs_dir = '.';
my $strict = 1;
my $mode = 1;
my $kdiff = 0;

GetOptions(
   'from|f=s'     =>  \$specs_dir,
   'to|t=s'       =>  \$module_dir,
   'detailed|d!'  =>  \$mode,
   'strict|s!'    =>  \$strict,
   'kdiff|k!'     =>  \$kdiff,
   'help|h'       =>  \$help,
) or pod2usage(1);

pod2usage({-verbose => 2, -exitval => 0}) if $help;
pod2usage({-msg => "Wrong arguments.\n", -exitval => 2 }) unless -d $module_dir && -d $specs_dir;


#Global variables from Local::C::Transformation
my $comment_re = $comment_t{pattern};
my $macro_re   = $macro_t{pattern};


sub call_meld
{
   return 1 if $#_ > 2;

   my @template = qw/from_ to_ merge_/;
   my @f;
   foreach my $i (0 .. $#_) {
      my (undef, $name) = tempfile(TEMPLATE => $template[$i], SUFFIX => '.c');
      push @f, $name;

      write_file($name, @{$_[$i]})
   }

   my $ret;
   if ($kdiff) {
      $ret = system('kdiff3', @f)
   } else {
      $ret = system('meld', @f)
   }

   @{$_[-1]} = read_file($f[-1])
      unless $ret;

   unlink $f[$_] for 0 .. $#_;

   $ret
}

# dir
# returns hash ref
sub fetch_module_sources
{
   my @module  = find_all_files($_[0]);

   return {}
      unless @module;

   my %module;
   foreach my $f (@module) {
      $module{$f}{code} = read_file($f);
      adapt($module{$f}{code},
            comments => \@{ $module{$f}{c} },
            macro    => \@{ $module{$f}{m} }
      );

      my %i;
      foreach (0 .. $#{ $module{$f}{c} }) {
         $i{$_} = 1 if is_acsl_spec(@{ $module{$f}{c} }[$_])
      }
      $module{$f}{i} = \%i;
   }

   %module
}

sub fetch_specifications
{
   my $code = merge_all_files_simple($_[0]);

   return {}
      unless $code;

   adapt($code,
         comments => \my @comments,
         macro    => \my @macro
   );

   (
      specs    => \$code,
      comments => \@comments,
      macro    => \@macro
   )
}

sub simple_preprocess
{
   my $cntx = $_[0];
   my ($code, $comments, $macro) = @{$cntx}{qw/code comments macro/};

   my $skip = 0;
   my $ifdef_rec = 0;
   my ($begin, $end) = (undef, undef);
   my ($ML, $MR) = @macro_t{qw(L R)};

   foreach my $i (0 .. $#$macro)
   {
      unless ($skip) {
         if ($macro->[$i] =~ m/^\h*+#\h*+if\h*+0/) {
            $skip = 1;
            $begin = $i;
            $ifdef_rec = 0;
         }
      } else {
         if ($macro->[$i] =~ m/^\h*+#\h*+if(?:(?:n)?def)?/) {
            ++$ifdef_rec;
         } elsif ($macro->[$i] =~ m/^\h*+#\h*+endif/) {
            if ($ifdef_rec == 0) {
               $skip = 0;
               $end = $i;

               #remove part of the code
               $$code =~ m/$ML${begin}$MR/;
               $begin = $-[0];
               $$code =~ m/$ML${end}$MR/;
               $end = $+[0];
               my $remove = substr($$code, $begin, $end - $begin, '');

               #exclude comments from
               $comments->[$_] = '' foreach ($remove =~ m/$comment_re/g);
            } else {
               --$ifdef_rec;
            }
         }
      }
   }
}


sub move_specs
{
   my ($fret, $spec, $file, $module, $sbegin, $send) = @_;

   my @interval;
   my $continue = 0;
   my ($cb, $ce) = (0, 0);

   while ($fret =~ m/$comment_t{pattern}/g) {
      my ($b, $e) = ($-[0], $+[0]);
      if (exists $module->{$file}{i}{$1}) {
         if ($continue) {
            $ce = $e + 1;
         } else {
            $cb = $b;
            $ce = $e + 1;
         }

         $continue = 1;
      } else {
         push @interval, ($cb, $ce);
         $continue = 0;
      }
   }
   push @interval, ($cb, $ce);

   while (@interval) {
      $ce = pop @interval;
      $cb = pop @interval;
      substr($fret, $cb, $ce - $cb, '');
   }
   $fret =~ s/\b(?=[a-zA-Z_])/$spec/;

   substr($module->{$file}{code}, $sbegin, $send - $sbegin, $fret);
}


### Fetching module sources from dir: $module_dir
my %module = fetch_module_sources($module_dir);
die(RED . "Can't find module sources." . RESET . "\n")
   unless %module;

### Fetching specifications from dir: $specs_dir
my %specs = fetch_specifications($specs_dir);
die(RED . "Can't find specifications sources." . RESET . "\n")
   unless %specs;

### simple preprocessing step
simple_preprocess(\%specs);

my @comments = @{ $specs{comments} };
my @macro    = @{ $specs{macro}    };
my $code     = ${ $specs{specs}    };


my %acsl_specs;
### detecting specifications
foreach(0 .. $#comments) {
   $acsl_specs{$_} = 1 if is_acsl_spec($comments[$_]);
}

#funcs init
my %f;
my $ret  = qr/(?<ret>[\w$Local::C::Transformation::special_symbols][\w\s\*$Local::C::Transformation::special_symbols]+)/;
my $name = qr/(?<name>$varname)/;
my $args = qr'(?>(?<args>\((?:(?>[^\(\)]+)|(?&args))*\)))';
my $body = qr'(?>(?<fbody>\{(?:(?>[^\{\}]+)|(?&fbody))*\}))';

while ($code =~ m/$ret${s}*+\b$name${s}*+$args${s}*+(?:$body|;)/g) {
   my ($fret, $fname, $fargs, $fbody) = @+{qw/ret name args fbody/};
  
   if ($fret =~ m/^\s*($comment_re(\s*$comment_re)*).*$/s) {
      my $spec = $1;
      my $ret_pattern = substr($fret, $+[1]) =~ s/\s+//gsr;
      my @exclude_specs;

      $spec =~ s/$comment_re/if (exists $acsl_specs{$1}) {push @exclude_specs, $1; "$comments[$1]"} else {''}/eg;
      next if $spec =~ m/^\s++$/s;
      $spec = trim $spec;
      $spec .= "\n";

      my $args_pattern = $fargs =~ s/\s+//gr;

      my $done = 0;
      foreach (keys %module) {
         #only one function in one file
         if ($module{$_}{code} =~ m/$ret\b\Q$fname\E${s}*+$args${s}*+$body/) {
            my ($sbegin, $send) = ($-[1], $+[1]);
            my ($bbegin, $bend) = ($-[3], $+[3]);
            my ($fret, $fargs, $nbody) = @+{qw/ret args fbody/};

            #additional checks
            if ($strict) {
               if ($args_pattern ne $fargs =~ s/\s+//gr) {
                  warn "$_: " . RED . 'arguments' . RESET . " of function " . GREEN . $fname . RESET . " doesn't match.\n";
                  next;
               }

               $fret =~ m/[a-zA-Z_]/;
               if ($ret_pattern ne substr($fret, $-[0]) =~ s/\s+//gr) {
                  warn "$_: " . RED . 'return type' . RESET . " of function " . GREEN . $fname . RESET . " doesn't match.\n";
                  next;
               }
            }

            my $specs_exists = 0;
            if ($fbody) {
               while ($fbody =~ m/$comment_re/g) {
                  if (exists $acsl_specs{$1}) {
                     $specs_exists = 1;
                     last
                  }
               }
            }
            if ($specs_exists) {
               unless ($mode) {
                  $fbody =~ s/$comment_re/delete $acsl_specs{$1}; "$comments[$1]"/eg;
                  $fbody =~ s/$macro_re/$macro[$1]/g;
                  substr($module{$_}{code}, $bbegin, $bend - $bbegin, $fbody)
               } else {
                  my $fbody_saved = $fbody;
                  my @exclude_specs;
                  my @intervals;

                  $fbody =~ s/$macro_re/$macro[$1]/g;
# This code remove simple comments from new_code. Not very useful.
#                  while ($fbody =~ m/^[ \t]*$comment_re(?:[ \t]*+|$comment_re)*\n/gmp){
#                     my ($b, $e) = ($-[0], $+[0]);
#                     my @m = ${^MATCH} =~ m/$comment_re/g;
#                     my $cond = 0;
#
#                     foreach (@m) {
#                        $cond = 1 if exists $acsl_specs{$_}
#                     }
#                     unless ($cond) {
#                        push @intervals, ($b, $e)
#                     }
#                  }
#                  while (@intervals) {
#                     my $e = pop @intervals;
#                     my $b = pop @intervals;
#                     substr($fbody, $b, $e - $b, '');
#                  }
                  $fbody =~ s/$comment_re/if (exists $acsl_specs{$1}) {${^MATCH}} else {$comments[$1]}/egp;

                  $nbody =~ s/$macro_re/$module{$_}{m}->[$1]/g;
                  $nbody =~ s/$comment_re/if (exists $module{$_}{i}{$1}) {${^MATCH}} else {$module{$_}{c}->[$1]}/egp;

                  my @new_code = map { split(/^/, $_) } $fbody;
                  my @old_code = map { split(/^/, $_) } $nbody;
                  my @code;

                  my $cant_resolve = 0;

                  traverse_sequences(
                     \@old_code,
                     \@new_code,
                     {
                        MATCH     => sub { push @code, $new_code[$_[1]] },
                        DISCARD_A => sub { push @code, $old_code[$_[0]] },
                        DISCARD_B => sub {
                           if ($new_code[$_[1]] =~ m/^(?:\s++|$comment_re)*$/) {
                              push @code, $new_code[$_[1]];
                           } elsif ($new_code[$_[1]] =~ m/$comment_re/) {
                              $cant_resolve = 1;
                              push @code, $new_code[$_[1]];
                           } else {
                              $cant_resolve = 1;
                           }
                        }
                     },
                     sub { $_[0] =~ s/\s+|[(){}\[\];]|$comment_re//gr }
                  );

                  @code = split(/^/, join('', @code) =~ s/$comment_re/push @exclude_specs, $1;$comments[$1]/ger);

                  if ($cant_resolve) {
                     my $function = $fret . ' ' . $fname . $fargs;
                     $function =~ s/$comment_re//g;
                     $function =~ s/\s+/ /g;
                     $function =~ s/^\s+//g;
                     $function =~ s/\n//g;
                     $function .= "\n";

                     @old_code = split(/^/, join('', @old_code) =~ s/$comment_re/$module{$_}{c}->[$1]/gr);
                     @new_code = split(/^/, $fbody_saved =~ s/$comment_re/$comments[$1]/gr);

                     unshift @old_code, $function;
                     unshift @new_code, $function;
                     unshift @code,     $function;

                     warn "Problems calling " . RED . ($kdiff ? 'kdiff3' : 'meld') . RESET .
                        ". Note, that changes in function '" . GREEN . $fname . RESET . "' will be merged anyway.\n"
                           if call_meld(\@old_code, \@new_code, \@code);

                     shift @old_code;
                     shift @new_code;
                     my $check = shift @code;
                     warn "Changes in string '" . GREEN . substr($check, 0, -1) . RESET . "' will not be merged.\n"
                        if $check ne $function;
                  }

                  delete $acsl_specs{$_} foreach @exclude_specs;
                  substr($module{$_}{code}, $bbegin, $bend - $bbegin, join('', @code));
               }
            }

            move_specs($fret, $spec, $_, \%module, $sbegin, $send);

            $done = 1;
            last;
         }
      }
      unless ($done) {
         warn "Can't find function " . GREEN . $fname . RESET "\n"
      } else {
         delete $acsl_specs{$_} foreach @exclude_specs
      }
   }
}


foreach my $f (keys %module) {
   $module{$f}{code} =~ s/$macro_re/$module{$f}{m}->[$1]/g;
   $module{$f}{code} =~ s/$comment_re/$module{$f}{c}->[$1]/g;
   write_file($f, $module{$f}{code});
}


if (keys %acsl_specs) {
   my (undef, $col) = window_size();

   warn RED, "Can't merge following specifications:" . RESET . "\n\n";
   warn join("\n" . BLUE . '-' x $col . RESET, map { $comments[$_] } sort keys %acsl_specs) . "\n";
}

