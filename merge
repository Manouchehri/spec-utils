#!/usr/bin/env perl

use warnings;
use strict;

use re '/aa';
use feature qw(say);

use lib::abs 'lib';

use utf8;

use RE::Common qw($varname);
use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Pod::Usage;
use Term::ANSIColor qw(:constants);
use File::Temp qw(tempfile);
use Algorithm::Diff qw(traverse_sequences);

use Local::String::Utils qw(trim is_blank ne_spaces normalize);
use Local::List::Utils qw(str_to_list);
use Local::Terminal qw(window_size);
use Local::C::Transformation qw(adapt restore filter filter_dup restore_macro restore_comments :RE :TYPES);
use Local::GCC::Preprocess qw(preprocess_directives_noincl);
use Local::File::Merge qw(merge);
use Local::File::C::Merge qw(merge_all_files_simple find_all_files);
use ACSL::Common qw(is_acsl_spec);

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}


=encoding utf8

=pod

=head1 merge

merge - Переложение спецификаций с одной версии исходного кода на другую.

=head1 SYNOPSIS

 merge [options]
 Options:
  -f|--from dir      - откуда переносятся спецификации
  -t|--to dir        - куда переносятся спецификации
  -s|--[no-]strict   - осуществлять дополнительные проверки при сопоставлении функций
  -k|--[no-]kdiff    - использовать kdiff3 вместо meld
  -h|--help          - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-f|--from dir>

Указание на директорию, откуда переносятся спецификации. По умолчанию - текущая директория.

=item B<-t|--to dir>

Указание на директорию, куда переносятся спецификации. По умолчанию директория берётся из переменной окружения CURRENT_PROJECT.

=item B<-s|--[no-]strict>

Осуществлять точное сопоставление по аргументам и возвращаемому результату функций или отключить эти проверки. По умолчанию проверки включены.

=item B<-k|--[no-]kdiff>

Когда программа не в состоянии автоматически переместить спецификации, вызывается внешний инструмент. По умолчанию это программа meld. Опция включает использование программы kdiff3 вместо meld.

=item B<-h|--help>

Выводит данное сообщение.

=back

=head1 DESCRIPTION

Программа считывает спецификации из всех *.[ch] файлов директории --from и её поддиректорий. После пошагово переносит спецификации, прикреплённые к конкретным функциям на эти же функции из файлов директории --to и её поддиректорий. Какая функция в каком конкретном файле располагается не имеет значения. Старые спецификации, если они были, заменяются новыми. Для того, чтобы программа считала спецификацию прикреплённой к функции, необходимо чтобы последняя распологалась перед B<определением> функции. Если несколько спецификаций расположено подряд, то все они считаются прикреплёнными к одной функции.

Если программа не смогла найти функцию, для которой написаны спецификации, то выводится сообщение об ошибке. Работа программы при этом продолжается.

Обычные комментарии к функциям не переносятся. Комментарии внутри спецификаций переносятся.

На последнем этапе функционирования программа выводит в STDERR все спецификации, которые не были перенесены. Чаще всего это спецификации, которые прикреплены не к функциям.

=cut


my $help = 0;
# '' need for -d checking
my $module_dir = $ENV{CURRENT_PROJECT} // '';
my $specs_dir = '.';
my $strict = 1;
my $kdiff = 0;
my $tr_wh = 0;

GetOptions(
   'from|f=s'     =>  \$specs_dir,
   'to|t=s'       =>  \$module_dir,
   'strict|s!'    =>  \$strict,
   'kdiff|k!'     =>  \$kdiff,
   'rtw|r!'       =>  \$tr_wh, # remove trailing whitespaces
   'help|h'       =>  \$help,
) or pod2usage(1);

pod2usage({-verbose => 2, -exitval => 0}) if $help;
pod2usage({-msg => "Wrong arguments.\n", -exitval => 2 }) unless -d $module_dir && -d $specs_dir;


#Global variables from Local::C::Transformation
my $comment_re = $comment_t{pattern};
my $macro_re   = $macro_t{pattern};


sub call_meld
{
   return 1 if $#_ > 2;

   my @template = map {$_ . 'XXXX'} qw/to_ merge_ from_/;
   my @f;
   foreach my $i (0 .. $#_) {
      my (undef, $name) = tempfile(TEMPLATE => $template[$i], SUFFIX => '.c');
      push @f, $name;

      write_file($name, @{$_[$i]})
   }

   my $ret;
   if ($kdiff) {
      $ret = system('kdiff3', @f)
   } else {
      $ret = system('meld', @f)
   }

   @{$_[-1]} = read_file($f[-1])
      unless $ret;

   unlink $f[$_] for 0 .. $#_;

   $ret
}

# dir
# returns hash ref
sub fetch_module_sources
{
   my @module  = find_all_files($_[0]);

   return {}
      unless @module;

   my %module;
   foreach my $f (@module) {
      $module{$f}{code} = read_file($f);
      adapt($module{$f}{code},
            comments => \@{ $module{$f}{c} },
            macro    => \@{ $module{$f}{m} }
      );

      my %i;
      foreach (0 .. $#{ $module{$f}{c} }) {
         $i{$_} = 1 if is_acsl_spec(@{ $module{$f}{c} }[$_])
      }
      $module{$f}{i} = \%i;
   }

   %module
}

sub fetch_specifications
{
   my $code = merge_all_files_simple($_[0]);

   return {}
      unless $code;

   adapt($code,
         comments => \my @comments,
         macro    => \my @macro
   );

   (
      specs    => \$code,
      comments => \@comments,
      macro    => \@macro
   )
}

sub restore_specs_only ($$$)
{
   if (wantarray) {
      my @res;
      $_[0] =~ s/$comment_re/if (exists $_[2]->{$1}) {push @res, $1; $_[1]->[$1]} else {${^MATCH}}/egp;
      return @res
   } else {
      $_[0] =~ s/$comment_re/if (exists $_[2]->{$1}) {$_[1]->[$1]} else {${^MATCH}}/egp;
      return undef
   }
}

sub restore_comments_only ($$$)
{
   $_[0] =~ s/$comment_re/if (exists $_[2]->{$1}) {${^MATCH}} else {$_[1]->[$1]}/egp
}

sub get_spec_ids ($)
{
   my @res;

   push @res, $1 while $_[0] =~ m/$comment_re/g;

   @res
}

sub contains_specs
{
   if ($_[0]) {
      while ($_[0] =~ m/$comment_re/g) {
         return 1
            if exists $_[1]->{$1}
      }
   }

   0
}

my %index;
sub upd_merge_index
{
   # $file $begin $len $code
   $index{$_[0]}{$_[1]}{length} = $_[2];
   $index{$_[0]}{$_[1]}{code}   = $_[3];
}

sub move_specs
{
   my ($fret, $spec, $file, $module, $begin, $len) = @_;

   my @interval;
   my $continue = 0;
   my ($cb, $ce) = (0, 0);

   while ($fret =~ m/$comment_t{pattern}/g) {
      my ($b, $e) = ($-[0], $+[0]);
      if (exists $module->{$file}{i}{$1}) {
         if ($continue) {
            $ce = $e + 1;
         } else {
            $cb = $b;
            $ce = $e + 1;
         }

         $continue = 1;
      } else {
         push @interval, ($cb, $ce);
         $continue = 0;
      }
   }
   push @interval, ($cb, $ce);

   while (@interval) {
      $ce = pop @interval;
      $cb = pop @interval;
      substr($fret, $cb, $ce - $cb, '');
   }
   $fret =~ s/\b(?=[a-zA-Z_])/$spec/;

   upd_merge_index($file, $begin, $len, $fret);
}


### Fetching specifications from dir: $specs_dir
my %specs = fetch_specifications($specs_dir);
die(RED . "Can't find specifications sources." . RESET . "\n")
   unless %specs;

### Fetching module sources from dir: $module_dir
my %module = fetch_module_sources($module_dir);
die(RED . "Can't find module sources." . RESET . "\n")
   unless %module;

$specs{specs} = preprocess_directives_noincl($specs{specs});

my @comments = @{ $specs{comments} };
my @macro    = @{ $specs{macro}    };
my $code     = ${ $specs{specs}    };


my %acsl_specs;
### detecting specifications
foreach(0 .. $#comments) {
   if (is_acsl_spec($comments[$_])) {
      $acsl_specs{$_} = 1;
      $comments[$_] =~ s/\s+$//mg
         if $tr_wh;
   }
}


my $ret  = qr/(?<ret>[\w$Local::C::Transformation::special_symbols][\w\s\*$Local::C::Transformation::special_symbols]+)/;
my $name = qr/(?<name>$varname)/;
my $args = qr'(?>(?<args>\((?:(?>[^\(\)]+)|(?&args))*\)))';
my $body = qr'(?>(?<body>\{(?:(?>[^\{\}]+)|(?&body))*\}))';

my %s;
while ($code =~ m/$ret${s}*+\b$name${s}*+$args${s}*+(?:$body|;)/g) {
   my $name = $+{name};
   my $cond = exists $s{$name} && defined $s{$name}{body};
   if ($cond && !exists $+{body}) {
      # declaration; skipping
   } elsif ($cond) {
      warn "specs: Function $+{name} has been already defined.\n"
   } else {
      $s{$name}{ret}  = $+{ret};
      $s{$name}{args} = $+{args};

      $s{$name}{body} = $+{body}
         if exists $+{body};
   }
}

my %m;
foreach (keys %module) {
   while ($module{$_}{code} =~ m/$ret${s}*+\b$name${s}*+$args${s}*+(?:$body|;)/g) {
      my $name = $+{name};
      if (exists $s{$name} && !exists $m{$name}) {
         if (exists $+{body} == exists $s{$name}{body}) {
            if (exists $+{body}) {
               $m{$name}{body_idx} = [$-[4], $+[4] - $-[4]];
               $m{$name}{body} = $+{body};
            } else {
               next
                  unless contains_specs $+{ret}, $module{$_}{i}
            }

            $m{$name}{file} = $_;

            $m{$name}{ret_idx}  = [$-[1], $+[1] - $-[1]];
            $m{$name}{ret}  = $+{ret};
            $m{$name}{args} = $+{args};
         }
      }
   }
}


foreach (keys %s) {
   if ($s{$_}{ret} =~ m/($comment_re(\s*+$comment_re)*+).*\Z/s) {
      my $cs = $s{$_};
      my $spec = $1;
      my @exclude_specs;

      push @exclude_specs, restore_specs_only($spec, \@comments, \%acsl_specs);
      filter $spec;
      next
         if is_blank $spec;
      $spec = trim $spec;
      $spec .= "\n";

      if (exists $m{$_}) {
         my $cm = $m{$_};
         my $file = $cm->{file};

         #additional checks
         if ($strict) {
            if (ne_spaces(filter_dup($cs->{args}), filter_dup($cm->{args}))) {
               warn "$cm->{file}: " . RED . 'arguments' . RESET . " of function " . GREEN . $_ . RESET . " doesn't match.\n";
               next
            }

            if (ne_spaces(filter_dup($cs->{ret}), filter_dup($cm->{ret}))) {
               warn "$cm->{file}: " . RED . 'return type' . RESET . " of function " . GREEN . $_ . RESET . " doesn't match.\n";
               next
            }
         }

         if (contains_specs $cs->{body}, \%acsl_specs) {
            my $fbody_saved = $cs->{body};
            my @exclude_specs;
            my @intervals;

            restore_macro($cs->{body}, \@macro);
            restore_comments_only($cs->{body}, \@comments, \%acsl_specs);

            restore_macro($cm->{body}, $module{$file}{m});
            restore_comments_only($cm->{body}, $module{$file}{c}, $module{$file}{i});

            my $new_code = str_to_list $cs->{body};
            my $old_code = str_to_list $cm->{body};
            my @code;

            my $cant_resolve = 0;

            traverse_sequences(
               $old_code,
               $new_code,
               {
                  MATCH     => sub { push @code, @$new_code[$_[1]] },
                  DISCARD_A => sub { push @code, @$old_code[$_[0]] },
                  DISCARD_B => sub {
                     if (@$new_code[$_[1]] =~ m/^(?:\s++|$comment_re)*$/) {
                        push @code, @$new_code[$_[1]];
                     } elsif (@$new_code[$_[1]] =~ m/$comment_re/) {
                        $cant_resolve = 1;
                        push @code, @$new_code[$_[1]];
                     } else {
                        $cant_resolve = 1;
                     }
                  }
               },
               sub { $_[0] =~ s/\s++|$comment_re//gr }
            );

            $code = join('', @code);
            # comments have been already restored
            push @exclude_specs, restore_specs_only($code, \@comments, \%acsl_specs);
            $code = str_to_list($code);

            if ($cant_resolve) {
               my $function = $cm->{ret} . ' ' . $_ . $cm->{args};
               filter($function);
               $function = normalize($function) . "\n";

               $old_code = join('', @$old_code);
               restore_comments($old_code, $module{$_}{c});
               $old_code = str_to_list($old_code);
               restore_comments($fbody_saved, \@comments);
               $new_code = str_to_list($fbody_saved);

               unshift $old_code, $function;
               unshift $new_code, $function;
               unshift $code,     $function;

               if (call_meld($old_code, $code, $new_code)) {
                  warn "Problems calling " . RED . ($kdiff ? 'kdiff3' : 'meld') . RESET .
                     ". Note, that changes in function '" . GREEN . $_ . RESET . "' will be merged anyway.\n"
               }

               shift $old_code;
               shift $new_code;
               my $check = shift $code;
               warn "Changes in string '" . GREEN . substr($check, 0, -1) . RESET . "' will not be merged.\n"
                  if $check ne $function;
            }

            delete $acsl_specs{$_} foreach @exclude_specs;
            upd_merge_index($file, @{ $cm->{body_idx} }, join('', @$code));
         }

         move_specs($cm->{ret}, $spec, $file, \%module, @{ $cm->{ret_idx} });
      }
      delete $acsl_specs{$_} foreach @exclude_specs
   }
}

foreach my $file (keys %index) {
   my $offset = 0;
   foreach my $pos (sort { $a <=> $b } keys $index{$file}) {
      substr($module{$file}{code}, $pos + $offset, $index{$file}{$pos}{length}, $index{$file}{$pos}{code});
      $offset += length($index{$file}{$pos}{code}) - $index{$file}{$pos}{length};
   }
}

foreach my $f (keys %module) {
   restore($module{$f}{code}, comments => $module{$f}{c}, macro => $module{$f}{m});
   write_file($f, $module{$f}{code});
}


if (keys %acsl_specs) {
   my (undef, $col) = window_size();

   warn RED, "Can't merge following specifications:" . RESET . "\n\n";
   warn join("\n" . BLUE . '-' x $col . RESET, map { $comments[$_] } sort keys %acsl_specs) . "\n";
}

