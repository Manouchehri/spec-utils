#!/usr/bin/env perl

use v5.20;
use feature qw/say signatures/;
use strict;
use warnings;
no warnings qw/experimental::signatures/;

use utf8::all;
use File::Temp qw/tempdir/;
use XML::Simple;
use IO::Interactive;
use Text::ANSITable;
use Class::CSV;
use File::Which;
#use ODF::lpOD;
use YAML::XS qw/LoadFile/;
use Getopt::Long;
use File::Slurp qw/write_file/;

use lib::abs 'lib';
use Local::List::Util qw/uniq/;
use C::FunctionSet;
use Kernel::Module::Graph qw/build_sources_graph/;
use Kernel::Module qw/preprocess_module_sources/;
use C::Util::Transformation;


unless (which('lizard')) {
   die "Please, install lizard python package. This program required to measure SLOC and CCN.\n"
}

my $modified = 0; #Calculate modified cyclomatic complexity number
my $output_format = 'table'; # table csv odf
my %config_file = (status => '.graph.conf', priority => '.graph.conf');
my $output_file = undef;
my $force = 0;
my ($kernel, $module) = @ENV{qw/CURRENT_KERNEL CURRENT_PROJECT/};

GetOptions(
    "modified!"    => \$modified,
    "kernel|k=s"   => \$kernel,
    "module|m=s"   => \$module,
    "force!"       => \$force,
    "status|s=s"   => \$config_file{status},
    "priority|p=s" => \$config_file{priority},
    "format|f=s"   => \$output_format,
    "output|o=s"   => \$output_file,
) or die("Error in command line arguments\n");

die "Please, provide valid path to kernel.\n"
    unless -d $kernel;
die "Please, provide valid path to module.\n"
    unless -d $module;

sub load_config
{
   if ($_[0] && -r $_[0]) {
      LoadFile( $_[0] )
   } else {
      undef
   }

}
my %config;
$config{status}   = load_config($config_file{status});
$config{priority} = load_config($config_file{priority});
die("Can't read config file.\n")
    unless $config{status} && $config{priority};

unless ($output_format eq 'table' || $output_format eq 'csv' || $output_format eq 'odf') {
   die "Format $output_format is not supported by the programm.\n"
}

if ($output_file && -f $output_file && !$force) {
   die "File $output_file already exists in the file system. If you want to overwrite, use --force option.\n"
}

#BEGIN OF A PROGRAM
my $preprocessed = get_preprocessed_sources($kernel, $module);

#Initializing the library
Kernel::Module::Graph::init(human_readable => 1);

my $graph = build_graph($preprocessed);
$graph = mark_priorities($graph, $config{priority});
$graph = resolve_function_function_cycles($graph);
$graph = mark_levels($graph);
my $metrics = create_table($graph, $preprocessed, $modified, $config{status});

# filter out __inittest and __check_enabled
delete $metrics->{__inittest};
delete $metrics->{__check_enabled};

output_plan(prepare_output_document($output_format, $output_file), $metrics);
##END OF A PROGRAM

sub get_preprocessed_sources($kernel, $module)
{
   my $source = (preprocess_module_sources($kernel, $module, ["#define SPECIFICATION 1\n"]))[1];
   adapt($$source, map {$_ => 1} qw/strings comments macro attributes/);
   $$source
}

# args $_[0] - preprocessed file
sub get_metrics
{
   my $modified = pop;
   #creating temp file
   my $tempdir = tempdir(TMPDIR => 1, CLEANUP => 1);
   open my $fh, '>', "$tempdir/sources.c";
   print $fh $_[0];
   close $fh;

   #calling lizard
   my $lizard_call = 'lizard -X ' . ($modified ? ' -m ' : '') . $tempdir;
   my $xml = qx!$lizard_call!;
   my $xs  = XML::Simple->new();
   my $ref = $xs->XMLin($xml);
   my $items = $ref->{measure}[0]{item};
   my %metrics;
   foreach(keys %$items) {
      my $name = ($_ =~ m/(^[^\(]++)/)[0];
      my @value = @{$items->{$_}{value}}[1,2];
      $metrics{$name} = {SLOC => $value[0], CCN => $value[1]};
   }

   \%metrics
}

# args $_[0] - preprocessed file
sub build_graph
{
   my %sources;
   $sources{module}{function} = C::FunctionSet->parse(\$_[0], 'module');

   build_sources_graph(\%sources);
}

sub mark_priorities($graph, $config)
{
   while ( my ($i, $list) = each @{ $config->{priority}{lists} } ) {
      foreach (uniq @$list) {
         if ($graph->has_vertex($_)) {
            unless ($graph->has_vertex_attribute($_, 'priority')) {
               $graph->set_vertex_attribute($_, priority => $i + 1);
            }
            foreach ($graph->all_predecessors($_)) {
               unless ($graph->has_vertex_attribute($_, 'priority')) {
                  $graph->set_vertex_attribute($_, priority => $i + 1);
               }
            }
         } else {
            warn "Priority list: there is no such function '$_' in sources.\n"
         }
      }
   }

   $graph
}

sub resolve_function_function_cycles($graph)
{
   while ($graph->has_a_cycle) {
      my @cycle = $graph->find_a_cycle();
      if (@cycle == 1) {
         $graph->delete_edge(@cycle[0,0])
      } else {
         $graph->delete_edge(@cycle[0,1])
      }
   }

   $graph
}

sub mark_levels($graph)
{
   my %vertices = map {$_ => undef} $graph->vertices;
   my %vd  = map { ($_, $graph->in_degree($_)) } keys %vertices;
   my $level = 1;
   while (%vertices) {
      my @zv;

      foreach(keys %vertices) {
         push @zv, $_ if 0 == $vd{$_};
      }

      unless (@zv) {
         die "There is no possibility to continue. Cycle.\n";
         last;
      }

      $graph->set_vertex_attribute($_, level => $level)
          foreach @zv;

      --$vd{$_->[1]} foreach $graph->edges_from(@zv);
      delete @vertices{@zv};
      $level++;
   }

   $graph
}

sub create_table($graph, $preprocessed, $modified, $config)
{
   my $metrics  = get_metrics($preprocessed, $modified);

   my %done    = map {$_ => 'доказана'}               @{$config->{done}};
   my %lemma   = map {$_ => 'доказана без лемм'}      @{$config->{'lemma-proof-required'}};
   my %partial = map {$_ => 'частичная спецификация'} @{$config->{'partial-specs'}};
   my %specs   = map {$_ => 'недоказуемо'}            @{$config->{'specs-only'}};
   my %status = (%done, %lemma, %partial, %specs);

   my %vertices = map {$_ => undef} $graph->vertices;

   foreach (keys %vertices) {
      my $obj = $graph->get_vertex_attribute($_, 'object');
      my @calls = grep {! m/^__builtin/} @{$obj->calls}; # filter builtin compiler functions
      my @module_calls = grep {exists $vertices{$_}} @calls;
      my @kernel_calls = grep {!exists $vertices{$_}} @calls;
      my @args = grep {! m/^void$/} split /,/, $obj->args =~ s/[)(\s]++//gr;

      $metrics->{$_}{priority}       = $graph->get_vertex_attribute($_, 'priority');
      $metrics->{$_}{level}          = $graph->get_vertex_attribute($_, 'level');
      $metrics->{$_}{status}         = $status{$_} // '';
      $metrics->{$_}{module_calls}   = scalar @module_calls;
      $metrics->{$_}{kernel_calls}   = scalar @kernel_calls;
      $metrics->{$_}{args}           = scalar @args;
   }

   $metrics
}

sub _weight
{
   my ($args, $sloc, $ccn, $kernel_calls, $module_calls) = @_;

   0.2 * $args + ($sloc * 0.3 + $ccn) + ($kernel_calls * 0.5 + $module_calls) * 0.4
}

sub generate_sort_function
{
   my $metrics = $_[0];

   sub {
      my $la = $metrics->{$a}{level};
      my $lb = $metrics->{$b}{level};
      my $pa = $metrics->{$a}{priority} || 10000;
      my $pb = $metrics->{$b}{priority} || 10000;

      my $wa = _weight(@{$metrics->{$a}}{qw/args SLOC CCN kernel_calls module_calls/});
      my $wb = _weight(@{$metrics->{$b}}{qw/args SLOC CCN kernel_calls module_calls/});

      $pa <=> $pb
          ||
      $la <=> $lb
          ||
      $wa <=> $wb
   }
}

sub prepare_output_document($output_format, $output_file)
{
   my $column_names = ['№', 'Имя', 'Аргументы', 'SLOC', 'CCN', 'Вызвано функций ядра', 'Вызвано функций модуля',
       'Приоритет', 'Уровень в иерархии', 'Статус Верификации'];
   my $obj;
   my $addfunc;
   my $retfunc;
   my $outfunc = sub {
                        if ($output_file) {
                           write_file($output_file, { binmode => ':utf8' }, $_[0])
                        } else {
                           print $_[0]
                        }
                     };

   if ($output_format eq 'table') {
      my $t = Text::ANSITable->new;
      $t->border_style('Default::bold');
      if (IO::Interactive::is_interactive() && !$output_file) {
         $t->color_theme('Default::default_gradation');
      } else {
         $t->color_theme('Default::no_color');
      }

      $t->columns($column_names);
      $t->set_column_style('№',                      pad    => 0);
      $t->set_column_style('Имя',                    align  => 'left');
      $t->set_column_style('Аргументы',              align  => 'middle');
      $t->set_column_style('SLOC',                   align  => 'middle');
      $t->set_column_style('CCN',                    align  => 'middle');
      $t->set_column_style('Вызвано функций ядра',   align  => 'middle');
      $t->set_column_style('Вызвано функций модуля', align  => 'middle');
      $t->set_column_style('Приоритет',              align  => 'middle');
      $t->set_column_style('Уровень в иерархии',     align  => 'middle');
      $t->set_column_style('Статус Верификации',     align  => 'middle');

      $obj = $t;
      $addfunc = \&Text::ANSITable::add_row;
      $retfunc = \&Text::ANSITable::draw;
   } elsif ($output_format eq 'csv') {
      my $csv = Class::CSV->new(
          fields         => $column_names,
          line_separator => "\r\n",
          csv_xs_options => {
              sep_char          => ';',
          },
      );

      $obj = $csv;
      $addfunc = \&Class::CSV::add_line;
      $retfunc = \&Class::CSV::string;
   } elsif ($output_format eq 'odf') {
=test
      my $document = odf_new_document('text');
      my $meta = $document->get_part(META);
      $meta->set_title('Verification Plan.');

      my $content = $document->get_part(CONTENT);
      my $context = $content->get_body;
      my $width = scalar @$column_names;
      my $table = odf_table->create('Plan', width => $width);
      $context->append_element($table);
      $table->add_row();

      my @cells = $table->get_cells(0, 0, 0, $width);
      foreach (@{$cells[0]}) {
         $_->set_value('TEST');
      }
      #$table->set_column_header();


      $obj = [$document, $table];
      $addfunc = sub { my $t = $_[0]->[1]; my $r = $t->add_row(); use Data::Printer; p $r; exit;};
      $retfunc = sub { $_[0]->[0] }; # return document from obj
      $outfunc = sub { $_[0]->save(target => 'report.odt') }; # document->save
=cut
   } else {
      die "Program doesn't have support for output format $output_format.\n"
   }

   ($obj, $addfunc, $retfunc, $outfunc)
}

sub output_plan($obj, $addfunc, $retfunc, $outfunc, $metrics)
{
   my $counter = 1;
   my $sort_function = generate_sort_function($metrics);
   foreach (sort $sort_function keys %$metrics) {
      $addfunc->($obj, [$counter++, $_,
              @{$metrics->{$_}}{qw/args SLOC CCN kernel_calls module_calls priority level status/}]);
   }

   $outfunc->($retfunc->($obj));
}
