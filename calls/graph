#!/usr/bin/env perl

use common::sense;
use utf8::all;

use Graph;
use Graph::Writer::Dot;

use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Storable;
use YAML::XS qw(LoadFile);
use FindBin;

use lib "$FindBin::Bin/../lib/";

use Local::List::Utils qw(uniq difference);
use Local::C::Transformation;
use Local::C::Parsing qw(parse_calls);
use Local::Kernel::Module qw(preprocess_module_sources);
use Local::Kernel::Module::Graph qw(build_sources_graph get_successors_subgraph);

use C::FunctionSet;


my $function;
my $format = 'png';
my $out = 'graph';
my $parsec_dir = $ENV{PARSEC_SOURCES} // '.';
my $kernel_dir = $ENV{PARSEC_KERNEL_SOURCES} // '.';
my $preprocessed;
my $cache = 1;
my $cache_dir = "$FindBin::Bin/.cache";
my $cache_file = 'graph_map.cache';
my $conf_file = '.graph.conf';
my $done = 1;
my $priority = 1;
my $issues = 0;

GetOptions(
   'function|f=s'     =>  \$function,
   'format=s'         =>  \$format,
   'output|o=s'       =>  \$out,
   'preprocessed|p=s' =>  \$preprocessed,
   'sources|s=s'      =>  \$parsec_dir,
   'kernel|k=s'       =>  \$kernel_dir,
   'cache!'           =>  \$cache,
   'done!'            =>  \$done,
   'priority!'        =>  \$priority,
   'issues|i!'        =>  \$issues
) or die "Incorrect usage!\n";

die("$parsec_dir is not a directory.\n") if ! -d $parsec_dir;
die("$kernel_dir is not a kernel directory.\n") if ! -f "$kernel_dir/Kbuild";


$cache = 0 if $preprocessed;

if ($cache_dir) {
   mkdir($cache_dir) or
      die("Can't create directory $cache_dir: $!\n")
         if ! -e $cache_dir;

   $cache_file = "$cache_dir/$cache_file";
}

$cache = 0 if ! -r $cache_file;

my $conf;
$conf = LoadFile($conf_file)
   if -r $conf_file;


goto CACHE if $cache;


# read sources
my $source;
if ($preprocessed) {
   $source = read_file($preprocessed, scalar_ref => 1);
} else {
   $source = (preprocess_module_sources($kernel_dir, $parsec_dir, ["#define SPECIFICATION 1\n"]))[3];
}
adapt($$source, attributes => 1);

#funcs init
my %sources;
$sources{module}{function} = C::FunctionSet->parse($source, 'module');
my $graph = build_sources_graph(\%sources, 1, 1);

#these are special kernel functions generated after preprocessing
$graph->delete_vertices( qw(__check_enabled __inittest) );

CACHE: if ($cache) {
   $graph = retrieve($cache_file)
} else {
   store($graph, $cache_file)
}


#1
$graph->set_vertex_attribute($_, shape => 'octagon')
   foreach $graph->successorless_vertices();

#2
if ($priority) {
   foreach my $list (@{ $conf->{priority}{lists} }) {
      my $color = $conf->{priority}{colors}{$list};

      foreach (uniq @$list) {
         if ($graph->has_vertex($_)) {
            $graph->set_vertex_attribute($_, style => 'filled' );
            $graph->set_vertex_attribute($_, fillcolor => $color );
            $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );

            foreach ($graph->all_successors($_)) {
               unless ($graph->has_vertex_attribute($_, 'fillcolor')) {
                  $graph->set_vertex_attribute($_, style => 'filled' );
                  $graph->set_vertex_attribute($_, fillcolor => $color );
               }
            }
         } else {
            warn "Priority list: there is no such function '$_' in sources.\n"
         }
      }
   }
}

#3
if ($done) {
   #sub label_done { "\N{BALLOT BOX WITH CHECK} " . join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   #sub label_done { join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   sub label_done { "\N{BALLOT BOX WITH CHECK} " . $_[0] }

   foreach (uniq @{ $conf->{done} }) {
      if ($graph->has_vertex($_)) {
         $graph->set_vertex_attribute($_, 'label', label_done($_));
         $graph->set_vertex_attribute($_, style => 'dashed');
         $graph->set_vertex_attribute($_, done => 1);
      } else {
         warn "Thehe is no function: '$_'\n"
      }
   }
}

#4
my %used_issues;
if ($issues) {
   foreach (keys %{ $conf->{issues} }) {
      foreach my $v ($graph->vertices) {
         if ($graph->get_vertex_attribute($v, 'object')->code =~ m/$conf->{issues}{$_}{re}/) {
            $used_issues{$_} = undef;

            unless ($graph->has_vertex_attribute($v, 'done')) {
               unless ($graph->get_vertex_attribute($v, 'shape') eq 'record') {
                  $graph->set_vertex_attribute($v, shape => 'record');
                  $graph->set_vertex_attribute($v, style =>
                     $graph->get_vertex_attribute($v, 'style') . ',bold');
                  $graph->set_vertex_attribute($v, label => "\N{SALTIRE} $v | $_");
               } else {
                  $graph->set_vertex_attribute($v, label =>
                     $graph->get_vertex_attribute($v, 'label') . " | $_")
               }
            } else {
               warn "Issue $_ in vertex '$v'\n"
            }
         }
      }
   }

   my @diff = difference([ keys %{ $conf->{issues} } ], [ keys %used_issues ]);
   if (@diff) {
      warn "Issues @diff is/are useless, since there is no vertices marked.\n"
   }
}

if ($function) {
   if ($graph->has_vertex($function)) {
      $graph = get_successors_subgraph($graph, $function)
   } else {
      warn "There is no such function: '$function'.\n"
   }
}

{
   local $SIG{__WARN__} = sub {};
   Graph::Writer::Dot->new()->write_graph($graph, "$out.dot")
}

if ($priority || $issues) {
   my @legenda;

   if ($issues) {
      push @legenda, qq(  subgraph "cluster_issues_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Issues legenda";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      my $edges = join(' -> ', map { "\"$_\"" } keys %used_issues);
      push @legenda, qq(    $edges [ style = "invis" ];\n);
      foreach (keys %used_issues) {
         push @legenda, qq(    "$_" [label = "$_: $conf->{issues}{$_}{description}", fillcolor = "white"];\n);
      }
      push @legenda, qq(  }\n);
   }

   if ($priority) {
      push @legenda, qq(  subgraph "cluster_priority_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Priorities legenda";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      push @legenda, qq(    "1" -> "2" -> "3" -> "4" -> "5" [ style = "invis" ];\n);
      my $colors = [ map { $conf->{priority}{colors}{$_} } @{ $conf->{priority}{lists} } ];
      while (my ($idx, $color) = each $colors) {
         ++$idx;
         push @legenda, qq(    "$idx" [fillcolor = "$color"];\n);
      }
      push @legenda, qq(  }\n);
   }

   my @dot = read_file("$out.dot", { binmode => ':utf8' });
   splice @dot, 2, 0, @legenda;
   write_file("$out.dot", { binmode => ':utf8' }, @dot);
}

fork and exit;
exec('dot', "-T${format}", "${out}.dot", "-o${out}.${format}");

