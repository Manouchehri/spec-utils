#!/usr/bin/env perl

use common::sense;
use utf8::all;

use Graph;
use Graph::Writer::Dot;

use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Storable;
use YAML::XS qw(LoadFile);
use FindBin;

use lib "$FindBin::Bin/../lib/";

use Local::List::Utils qw(uniq);
use Local::C::Transformation;
use Local::C::Parsing qw(parse_calls);
use Local::Kernel::Module qw(preprocess_module_sources);
use Local::Kernel::Module::Graph qw(build_sources_graph get_successors_subgraph);

use C::FunctionSet;


my $function;
my $format = 'png';
my $out = 'graph';
my $parsec_dir = $ENV{PARSEC_SOURCES} // '.';
my $kernel_dir = $ENV{PARSEC_KERNEL_SOURCES} // '.';
my $preprocessed;
my $cache = 1;
my $cache_dir = "$FindBin::Bin/.cache";
my $cache_file = 'graph_map.cache';
my $conf_file = '.graph.conf';
my $done = 1;
my $priority = 1;

GetOptions(
   'function|f=s'     =>  \$function,
   'format=s'         =>  \$format,
   'output|o=s'       =>  \$out,
   'preprocessed|p=s' =>  \$preprocessed,
   'sources|s=s'      =>  \$parsec_dir,
   'kernel|k=s'       =>  \$kernel_dir,
   'cache!'           =>  \$cache,
   'done!'            =>  \$done,
   'priority!'        =>  \$priority
) or die "Incorrect usage!\n";

die("$parsec_dir is not a directory.\n") if ! -d $parsec_dir;
die("$kernel_dir is not a kernel directory.\n") if ! -f "$kernel_dir/Kbuild";

if ($cache_dir) {
   mkdir($cache_dir) or
      die("Can't create directory $cache_dir: $!\n")
         if ! -e $cache_dir;

   $cache_file = "$cache_dir/$cache_file";
}

$cache = 0 if ! -r $cache_file;

my $conf;
$conf = LoadFile($conf_file)
   if -r $conf_file;


goto CACHE if $cache;


# read sources
my $source;
if ($preprocessed) {
   $source = read_file($preprocessed, scalar_ref => 1);
} else {
   $source = (preprocess_module_sources($kernel_dir, $parsec_dir, ["#define SPECIFICATION 1\n"]))[3];
}
adapt($$source, attributes => 1);

#funcs init
my %sources;
$sources{module}{function} = C::FunctionSet->parse($source, 'module');
my $graph = build_sources_graph(\%sources, 1, 1);


CACHE: if ($cache) {
   $graph = retrieve($cache_file)
} else {
   store($graph, $cache_file)
}


#1
$graph->set_vertex_attribute($_, shape => 'octagon')
   foreach $graph->successorless_vertices();

#2
if ($priority) {
   foreach my $list (@{ $conf->{priority}{lists} }) {
      my $color = $conf->{priority}{colors}{$list};

      foreach (@$list) {
         if ($graph->has_vertex($_)) {
            $graph->set_vertex_attribute($_, style => 'filled' );
            $graph->set_vertex_attribute($_, fillcolor => $color );
            $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );

            foreach ($graph->all_successors($_)) {
               unless ($graph->has_vertex_attribute($_, 'fillcolor')) {
                  $graph->set_vertex_attribute($_, style => 'filled' );
                  $graph->set_vertex_attribute($_, fillcolor => $color );
               }
            }
         } else {
            warn "Priority list: there is no such function '$_' in sources.\n"
         }
      }
   }
}

#3
if ($done) {
   #sub label_done { "\N{BALLOT BOX WITH CHECK} " . join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   #sub label_done { join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   sub label_done { "\N{BALLOT BOX WITH CHECK} " . $_[0] }

   foreach (@{$conf->{done}}) {
      if ($graph->has_vertex($_)) {
         $graph->set_vertex_attribute($_, 'label', label_done($_));
         $graph->set_vertex_attribute($_, style => 'dashed');
      } else {
         warn "Thehe is no function: '$_'\n"
      }
   }
}


if ($function) {
   if ($graph->has_vertex($function)) {
      $graph = get_successors_subgraph($graph, $function)
   } else {
      warn "There is no such function: '$function'.\n"
   }
}

{
   local $SIG{__WARN__} = sub {};
   Graph::Writer::Dot->new()->write_graph($graph, "$out.dot")
}

if ($priority) {
   my @legenda;

   my @dot = read_file("$out.dot");
   push @legenda, qq(  subgraph "cluster_legenda" {\n);
   push @legenda, qq(    style = "filled";\n);
   push @legenda, qq(    color = "lightgrey";\n);
   push @legenda, qq(    label = "Legenda";\n);
   push @legenda, qq(    node [shape = "box", style = "filled"];\n);
   push @legenda, qq(    "1" -> "2" -> "3" -> "4" -> "5" [ style = "invis" ];\n);
   my $colors = [ map { $conf->{priority}{colors}{$_} } @{ $conf->{priority}{lists} } ];
   while (my ($idx, $color) = each $colors) {
      ++$idx;
      push @legenda, qq(    "$idx" [fillcolor = "$color"];\n);
   }
   push @legenda, qq(  }\n);

   splice @dot, 2, 0, @legenda;
   write_file("$out.dot", @dot);
}

fork and exit;
exec('dot', "-T${format}", "${out}.dot", "-o${out}.${format}");

