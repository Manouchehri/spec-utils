#!/usr/bin/env perl

use common::sense;
use utf8::all;

use Graph;
use Graph::Writer::Dot;

use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Storable;
use YAML::XS qw(LoadFile);
use FindBin;

use lib "$FindBin::Bin/../lib/";

use Local::List::Utils qw(uniq difference);
use Local::C::Transformation;
use Local::C::Parsing qw(parse_calls);
use Local::Kernel::Module qw(preprocess_module_sources);
use Local::Kernel::Module::Graph qw(build_sources_graph get_successors_subgraph);

use C::FunctionSet;


my $function;
my $format = 'png';
my $out = 'graph';
my $parsec_dir = $ENV{PARSEC_SOURCES} // '.';
my $kernel_dir = $ENV{PARSEC_KERNEL_SOURCES} // '.';
my $preprocessed;
my $cache = 1;
my $cache_dir = "$FindBin::Bin/.cache";
my $cache_file = 'graph_map.cache';
my $conf_file = "$FindBin::Bin/.graph.conf";
my $done = 1;
my $priority = 1;
my $issues = 0;
my $stat = 0;
my $mark_anyway = 0;

GetOptions(
   'function|f=s'            =>  \$function,
   'format=s'                =>  \$format,
   'output|o=s'              =>  \$out,
   'preprocessed|p=s'        =>  \$preprocessed,
   'sources|s=s'             =>  \$parsec_dir,
   'kernel|k=s'              =>  \$kernel_dir,
   'cache!'                  =>  \$cache,
   'done!'                   =>  \$done,
   'priority!'               =>  \$priority,
   'issues|i!'               =>  \$issues,
   'statistics|stats|stat!'  =>  \$stat,
   'mark-anyway|m!'          =>  \$mark_anyway
) or die "Incorrect usage!\n";

die("$parsec_dir is not a directory.\n") if ! -d $parsec_dir;
die("$kernel_dir is not a kernel directory.\n") if ! -f "$kernel_dir/Kbuild";


$cache = 0 if $preprocessed;

if ($cache_dir) {
   mkdir($cache_dir) or
      die("Can't create directory $cache_dir: $!\n")
         if ! -e $cache_dir;

   $cache_file = "$cache_dir/$cache_file";
}

$cache = 0 if ! -r $cache_file;

my $conf;
if (-r $conf_file) {
   $conf = LoadFile($conf_file)
} else {
   die("Can't read config file.\n")
}


goto CACHE if $cache;


# read sources
my $source;
if ($preprocessed) {
   $source = read_file($preprocessed, scalar_ref => 1);
} else {
   $source = (preprocess_module_sources($kernel_dir, $parsec_dir, ["#define SPECIFICATION 1\n"]))[1];
}
adapt($$source, attributes => 1, comments => 1);

#funcs init
my %sources;
$sources{module}{function} = C::FunctionSet->parse($source, 'module');
my $graph = build_sources_graph(\%sources, 1, 1);

#these are special kernel functions generated after preprocessing
$graph->delete_vertices( qw(__check_enabled __inittest) );

CACHE: if ($cache) {
   $graph = retrieve($cache_file)
} else {
   store($graph, $cache_file)
}


#1
$graph->set_vertex_attribute($_, shape => 'octagon')
   foreach $graph->successorless_vertices();

#2
my $stat_done = 0;
if ($done) {
   #sub label_done { "\N{BALLOT BOX WITH CHECK} " . join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   #sub label_done { join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   sub label_done { state $mark = "\N{BALLOT BOX WITH CHECK} "; $mark . $_[0] }

   foreach (uniq @{ $conf->{done} }) {
      if ($graph->has_vertex($_)) {
         $graph->set_vertex_attribute($_, 'label', label_done($_));
         $graph->set_vertex_attribute($_, style   => 'dashed');
         $graph->set_vertex_attribute($_, done    => 1);
         $stat_done++;
      } else {
         warn "Done: there is no function: '$_'\n"
      }
   }
}

#3
my @stat_priority;
if ($priority) {
   while ( my ($i, $list) = each $conf->{priority}{lists} ) {
      my $color = $conf->{priority}{colors}{$list};
      my %stat = ( done => 0, remains => 0);

      foreach (uniq @$list) {
         if ($graph->has_vertex($_)) {

            unless ($graph->has_vertex_attribute($_, 'priority')) {
               unless ($graph->has_vertex_attribute($_, 'done')) {
                  $graph->set_vertex_attribute($_, style => 'filled' );
                  $graph->set_vertex_attribute($_, fillcolor => $color );
                  $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );
                  $stat{remains}++
               } else {
                  $stat{done}++
               }
               $graph->set_vertex_attribute($_, priority => $i + 1);
            } else {
               if ($mark_anyway) {
                  $graph->set_vertex_attribute($_, fillcolor => $color );
                  $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );
               }
               my $lev = $graph->has_vertex_attribute($_, 'priority');
               warn "'$_' has been already marked as $lev priority level function\n";
               next
            }

            foreach ($graph->all_successors($_)) {
               unless ($graph->has_vertex_attribute($_, 'priority')) {
                  unless ($graph->has_vertex_attribute($_, 'done')) {
                     $graph->set_vertex_attribute($_, style => 'filled' );
                     $graph->set_vertex_attribute($_, fillcolor => $color );
                     $stat{remains}++
                  } else {
                     $stat{done}++
                  }
                  $graph->set_vertex_attribute($_, priority => $i + 1);
               }
            }
         } else {
            warn "Priority list: there is no such function '$_' in sources.\n"
         }
      }

      push @stat_priority, \%stat;
   }
}

#4
my %used_issues;
if ($issues) {
   my $mark = "\N{SALTIRE}";
   foreach (keys %{ $conf->{issues} }) {
      foreach my $v ($graph->vertices) {
         if ($graph->get_vertex_attribute($v, 'object')->code =~ m/$conf->{issues}{$_}{re}/) {
            $used_issues{$_} = undef;

            unless ($graph->has_vertex_attribute($v, 'done')) {
               unless ($graph->get_vertex_attribute($v, 'shape') eq 'record') {
                  $graph->set_vertex_attribute($v, shape => 'record');
                  $graph->set_vertex_attribute($v, style =>
                     $graph->get_vertex_attribute($v, 'style') . ',bold');
                  $graph->set_vertex_attribute($v, label => "$mark $v | $_");
               } else {
                  $graph->set_vertex_attribute($v, label =>
                     $graph->get_vertex_attribute($v, 'label') . " | $_")
               }
            } else {
               warn "Issue $_ in already done function '$v'\n"
            }
         }
      }
   }

   my @diff = difference([ keys %{ $conf->{issues} } ], [ keys %used_issues ]);
   if (@diff) {
      warn "Issues @diff is/are useless, since there is no vertices marked.\n"
   }
}

if ($stat) {
   say "\n--- Статистика ---";
   say "Общее количество функций: " . $graph->vertices;
   if ($priority) {
      say "Функции по уровням приоритета:";
      print map
         {
            state $i = 0;
            ++$i;
            my $t = $_->{done} + $_->{remains};
            "\t[$i] общее количество: $t \tсделано: $_->{done} \tосталось: $_->{remains}\n"
         } @stat_priority;

      my ($done, $remains) = (0, 0);
      foreach ($graph->vertices) {
         unless ($graph->has_vertex_attribute($_, 'priority')) {
            if ($graph->has_vertex_attribute($_, 'done')) {
               $done++;
            } else {
               $remains++;
            }
         }
      }
      my $total = $done + $remains;
      say "Не вошедших в очереди приоритетов: $total; из них сделано $done; осталось $remains";
   }
   say "Всего сделано: " . $stat_done if $done;
}

if ($function) {
   if ($graph->has_vertex($function)) {
      $graph = get_successors_subgraph($graph, $function);

      say "Количество функций в подграфе $function: " . $graph->vertices
         if $stat;
   } else {
      warn "There is no such function: '$function'.\n"
   }
}


{
   local $SIG{__WARN__} = sub {};
   Graph::Writer::Dot->new()->write_graph($graph, "$out.dot")
}

if ($priority || $issues) {
   my @legenda;

   if ($issues) {
      push @legenda, qq(  subgraph "cluster_issues_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Issues legenda";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      my $edges = join(' -> ', map { "\"$_\"" } keys %used_issues);
      push @legenda, qq(    $edges [ style = "invis" ];\n);
      foreach (keys %used_issues) {
         push @legenda, qq(    "$_" [label = "$_: $conf->{issues}{$_}{description}", fillcolor = "white"];\n);
      }
      push @legenda, qq(  }\n);
   }

   if ($priority) {
      push @legenda, qq(  subgraph "cluster_priority_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Priorities legenda";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      push @legenda, qq(    "1" -> "2" -> "3" -> "4" -> "5" [ style = "invis" ];\n);
      my $colors = [ map { $conf->{priority}{colors}{$_} } @{ $conf->{priority}{lists} } ];
      while (my ($idx, $color) = each $colors) {
         ++$idx;
         push @legenda, qq(    "$idx" [fillcolor = "$color"];\n);
      }
      push @legenda, qq(  }\n);
   }

   my @dot = read_file("$out.dot", { binmode => ':utf8' });
   splice @dot, 2, 0, @legenda;
   write_file("$out.dot", { binmode => ':utf8' }, @dot);
}

say "\nFile $out.dot contains graph in dot format.";
say "File $out.${format} contains graph in ${format} format.";

fork and exit;
exec('dot', "-T${format}", "${out}.dot", "-o${out}.${format}");

