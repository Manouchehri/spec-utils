#!/usr/bin/env perl

use common::sense;

use Graph;
use Graph::Writer::Dot;

use File::Slurp qw(read_file write_file);
use Getopt::Long qw(:config gnu_getopt);
use Storable;
use FindBin;

use lib "$FindBin::Bin/../lib/";

use Local::List::Utils qw(uniq);
use Local::C::Transformation;
use Local::C::Parsing qw(parse_calls);
use Local::Kernel::Module qw(preprocess_module_sources);
use Local::Kernel::Module::Graph qw(build_sources_graph get_successors_subgraph);

use C::FunctionSet;


my $function;
my $format = 'png';
my $out = 'graph';
my $parsec_dir = $ENV{PARSEC_SOURCES} // '.';
my $kernel_dir = $ENV{PARSEC_KERNEL_SOURCES} // '.';
my $preprocessed;
my $priority_list = 'priority_list.txt';
my $cache = 1;
my $cache_dir = "$FindBin::Bin/.cache";
my $cache_file = 'graph_map.cache';

GetOptions(
   'function|f=s'     =>  \$function,
   'format=s'         =>  \$format,
   'output|o=s'       =>  \$out,
   'preprocessed|p=s' =>  \$preprocessed,
   'sources|s=s'      =>  \$parsec_dir,
   'kernel|k=s'       =>  \$kernel_dir,
   'cache!'           =>  \$cache
) or die "Incorrect usage!\n";

die("$parsec_dir is not a directory.\n") if ! -d $parsec_dir;
die("$kernel_dir is not a kernel directory.\n") if ! -f "$kernel_dir/Kbuild";

if ($cache_dir) {
   mkdir($cache_dir) or
      die("Can't create directory $cache_dir: $!\n")
         if ! -e $cache_dir;

   $cache_file = "$cache_dir/$cache_file";
}

$cache = 0 if ! -r $cache_file;

# pr list init
my %colormap;
my $curr_color;
my $cnt = 0;
my @colorlist;

my @pr = read_file($priority_list, chomp => 1);
foreach (@pr) {
   next if !$_;

   if (m/<(\w+)>/) {
      $curr_color = $1;
      ++$cnt;
      push @colorlist, $curr_color;
      next;
   }

   $colormap{$_} = [$cnt, $curr_color];
}

goto CACHE if $cache;


# read sources
my $source;
if ($preprocessed) {
   $source = read_file($preprocessed, scalar_ref => 1);
} else {
   $source = (preprocess_module_sources($kernel_dir, $parsec_dir, ["#define SPECIFICATION 1\n"]))[3];
}
adapt($$source, attributes => 1);

#funcs init
my %sources;
$sources{module}{function} = C::FunctionSet->parse($source, 'module');
my $graph = build_sources_graph(\%sources, 1, 1);


CACHE: if ($cache) {
   $graph = retrieve($cache_file)
} else {
   store($graph, $cache_file)
}


foreach (sort {$colormap{$a}[0] <=> $colormap{$b}[0]} grep {$graph->has_vertex($_)} keys %colormap) {
   my @subgraph;
   my $color = $colormap{$_}[1];

   $graph->set_vertex_attributes($_, { style => 'filled', fillcolor => $color, shape => 'tripleoctagon' } );

   foreach ($graph->all_successors($_)) {
      $graph->set_vertex_attributes($_,
            {
               style => 'filled',
               fillcolor => $color
            } )
         if !$graph->has_vertex_attribute($_, 'fillcolor')
   }
}

$graph->set_vertex_attribute($_, shape => 'octagon')
   foreach $graph->successorless_vertices();

if ($function) {
   die("There is no such function: '$function'.\n")
      unless $graph->has_vertex($function);
   $graph = get_successors_subgraph($graph, $function)
}

Graph::Writer::Dot->new()->write_graph($graph, "$out.dot");

my @legenda;

my @dot = read_file("$out.dot");
push @legenda, qq(  subgraph "cluster_legenda" {\n);
push @legenda, qq(    style = "filled";\n);
push @legenda, qq(    color = "lightgrey";\n);
push @legenda, qq(    label = "Legenda";\n);
push @legenda, qq(    node [shape = "box", style = "filled"];\n);
push @legenda, qq(    "1" -> "2" -> "3" -> "4" -> "5" [ style = "invis" ];\n);
while (my ($idx, $color) = each @colorlist) {
   ++$idx;
   push @legenda, qq(    "$idx" [fillcolor = "$color"];\n);
}
push @legenda, qq(  }\n);

splice @dot, 2, 0, @legenda;
write_file("$out.dot", @dot);

fork and exit;
exec('dot', "-T${format}", "${out}.dot", "-o${out}.${format}");

