[![Build Status](https://travis-ci.org/evdenis/spec-utils.svg?branch=devel)](https://travis-ci.org/evdenis/spec-utils)
[![Coverage Status](https://coveralls.io/repos/github/evdenis/spec-utils/badge.svg?branch=devel)](https://coveralls.io/github/evdenis/spec-utils?branch=devel)

В данном репозитории собран ряд утилит для изучения исходных кодов модуля ядра Linux и для работы с ними. Программы имеют внешние по perl модулям и другим программа. Для того, чтобы установить perl модули необходимо выполнить команды:
<pre>
cpan cpanm
cpanm --with-all-features --installdeps .
</pre>

Зависимости по иным программам описываются на отдельной странице [doc/EXTERNAL_DEPS.md](doc/EXTERNAL_DEPS.md)

Для удобства работы с программами можно задать переменные окружения:
* **CURRENT_PROJECT** - директория с исходными кодами исследуемого модуля ядра Linux
* **CURRENT_KERNEL**  - директория с исходными кодами ядра Linux с которым сочетается модуль

# Краткое описание функциональности программ

Каждая из программ имеет собственную man документацию, которая доступна по ключу --help. Здесь сведено вместе краткое описание программ, их функциональности и предназначения.

## Трансформация исходных кодов

Данные программы используются для работы с исходными кодами и разработки спецификаций.

* **dismember** - из исходных кодов "вытаскиваются" все зависимости для конкретных функций так, чтобы компилятор мог создать отдельный объектный файл. У инструментов верификации вызывает затруднение работа с большими объёмами кода, что проявляется в существенном замедлении их работы. Программа позволяет многократно сократить объём исходного кода за счёт того, что неиспользуемый код исключается. В получившемся коде функции расположены в соответствии с графом их вызовов, структуры и остальные сущности расположены так, чтобы программисту было наиболее удобно работать с получившимся набором исходных кодов.
[![asciicast](https://asciinema.org/a/186080.png)](https://asciinema.org/a/186080)
* **merge** - спецификации переносятся с одного набора исходных кодов на другой. Осуществляется полуавтоматическим образом. В случае невозможности автоматического разрешения конфликтов вызывается внешняя программа. Расположение функций в файлах не имеет значения.
[![asciicast](https://asciinema.org/a/186083.png)](https://asciinema.org/a/186083)

## Информация из исходных кодов

Данные программы предназначены для изучения исходных кодов модуля ядра как самостоятельного объекта. А также для изучения взаимодействия модулей с интерфейсом ядра. Используются при исследовании новых релизов исходных кодов, для подготовки отчётов и планирования работ.

* **graph** - строит карту исходных кодов. Карта представляет собой граф вызовов функций модуля ядра.
* **graph_diff** - строит карту различий между версиями графов вызовов разных релизов.
* **complexity_plan** - строит таблицу функций, где отображены метрики их сложности.
* **headers** - строит карту подключений заголовочных файлов в исходном коде.
* **calls** - программа для анализа и сбора статистики вызовов функций и функциональных макросов в модуле ядра. Автоматическое определение сущности функция/макрос, и места определения ядро/модуль.
* **lsm_diff** - программа для анализа интерфейса lsm ядра и его использования в модуле ядра.
* **stapgen** - по исходным кодам ядра создаёт скрипт для systemtap. Скрипт в динамике перехватывает вызовы lsm интерфейса ядра, осуществляет логирование параметров и контекста вызова функции. Позволяет отследить какие действия в ОС, приводят к вызову конкретных функций интерфейса lsm.
* **get_preprocessed** - осуществляет частичный (раскрываются только макросы ядра) либо полный препроцессинг исходных кодов модуля ядра.
* **recursion** - программа для детектирования рекурсии (прямой/косвенной) в исходных кодах модуля ядра Linux.
* **count_specifications** - программа для подсчета количества строк спецификаций на языке ACSL.
* **list_functions** - программа для вывода "плоского" списка функций модуля в соответствии с приоритетом.

Форматы конфигурационных файлов для этих программ описываются в отдельном файле [doc/FORMAT.md](doc/FORMAT.md)

# Интерактивная карта

## Пример карты для файловой системы fs/ext2

Разворачивается через docker. После карта доступна локально через проброс портов.
```bash
docker build -t ext2_callgraph .
docker run -d -p 127.0.0.1:8889:80 ext2_callgraph
firefox http://localhost:8889/graph
```

## Адрес

* только изображение: [http://localhost:8889/graph/image](http://localhost:8889/graph/image)
* html: [http://localhost:8889/graph](http://localhost:8889/graph)

Передвижение по карте - передвинуть указатель к границе окна. Изменить масштаб - колёсико мышки.

## GET параметры

* fmt=fmt - формат (svg|png|jpeg)
* func=func1,func2,... - функции через запятую (отображать не всю карту, а только от заданных функций)
* level=n - строить карту от функций приоритета n
* no-display-done=(0|1) - не отображать на карте проверифицированные функции (по умолчанию 0)
* reverse=(0|1) - строить карту не сверху вниз(какие функции вызываются из функций), а снизу вверх (какие функции могут вызвать функции) (по умолчанию 0)
* from-done=(0|1) - строить карту от проверифицированных функций (по умолчанию 0)
* available=(0|1) - показать доступные для верификации функции, исходя из проверифицированных к текущему моменту функций (по умолчанию 0)
* legenda=(0|1) - отображать список приоритетов на карте (по умолчанию 1)

Пример: [http://localhost:8889/graph/image?fmt=png&func=ext2_setattr,ext2_mknod](http://localhost:8889/graph/image?fmt=png&func=ext2_setattr,ext2_mknod)

Карта генерируется по коду для каждого запроса. Соответственно, если код/настройки уровней приоритетов меняются, то это будет отображено при следующем запросе. По умолчанию формат - svg. Если кликнуть мышкой по вершине, то будет осуществлён переход по адресу http://localhost:8889/graph/image?func={имя_вершины}
