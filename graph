#!/usr/bin/env perl

use warnings;
use strict;

use feature qw(say state);

use utf8::all;

use Graph;
use Graph::Writer::Dot;

use Pod::Usage;
use File::Slurp qw(read_file write_file);
use File::Which;
use Getopt::Long qw(:config gnu_compat no_bundling no_permute no_getopt_compat);
use Storable;
use YAML::XS qw(LoadFile);
use FindBin;

use lib "$FindBin::Bin/lib/";

use Local::List::Utils qw(uniq difference any);
use Local::C::Transformation;
use Local::C::Parsing qw(parse_calls);
use Local::Kernel::Common qw(check_kernel_dir autodetect_kernel_directory);
use Local::Kernel::Module qw(preprocess_module_sources);
use Local::Kernel::Module::Graph qw(build_sources_graph get_successors_subgraph);

use C::FunctionSet;


=encoding utf8

=pod

=head1 graph

graph - построить граф вызовов функций модуля ядра Linux

=head1 SYNOPSIS

 graph [options]
 Options:
  -s|--sources dir        - директория с исходными кодами модуля
                            (default: CURRENT_PROJECT || ./)

  -k|--kernel dir         - директория с исходными кодами ядра
                            (default: CURRENT_KERNEL || ../)

  -p|--preprocessed name  - файл с препроцессированным кодом модуля

  --[no-]cache            - [не]использовать сохранённые результаты обработки
                            исходных кодов
                            (default: on)

  --format fmt            - формат карты
                            (default: svg)

  -o|--output name        - имя (без расширения) для карты и .dot файла
                            (default: graph)

  -f|--functions f1 -f f2 ...
  -f|--functions f1,f2,...
  -f|--functions f1 f2 ... - строить граф от функций f1 f2 ...

  --[no-]priority         - отмечает на карте очереди приоритетов
                            (default: on)
  --[no-]done             - отмечает на карте проверифицированные функции
                            (default: on)
  -i|--[no-]issues        - помечает на карте issues
                            (default: off)

  -m|--[no-]mark-anyway   - помечать функции из списка приоритетов в любом случае
                            (default: off)

  --[no-]view             - открыть в стандартной программе для просмотра
                            изображений созданную карту
                            (default: off)
  -h|--help               - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-s|--sources dir>

Указание на директорию, где расположены исходные коды модуля ядра. По умолчанию директория берётся из переменной окружения I<CURRENT_SOURCES> если она задана, иначе используется текущая директория. Данные исходные коды в дальнейшем будут препроцессированы с директивой C<#define SPECIFICATION>.

=item B<-k|--kernel dir>

Указание на директорию, где расположены исходные коды ядра Linux. По умолчанию директория берётся из переменной окружения I<CURRENT_KERNEL> если она задана, иначе используется родительская директория текущей.

=item B<-p|--preprocessed name>

Указание на файл, в котором содержатся уже препроцессированные исходные коды. Данная опция не может указываться одновременно с опцией --sources. Так как они обе задают входные данные. Отличие состоит в том, что --sources указывает на директорию, где хранится множество непрепроцессированных файлов(которые соответствующим образом будут обработаны), а --preprocessed указывает на файл с кодом, где содержится код на чистом C.

=item B<--[no-]cache>

Программа при первом запуске кэширует результаты обработки исходного кода модуля ядра (файл F<.cache/graph_map.cache>). При последующих запусках используются сохранённые результаты. Чтобы программа не использовала их необходимо задать опцию --no-cache. В таком случае кэш будет обновлён.

=item B<--format fmt>

Формат графической карты. Поддерживаемые форматы (ps svg svgz fig png gif imap cmapx) соответствуют таковым для программы dot. По умолчанию используется формат svg.

=item B<-o|--output name>

Задаёт имя выходного файла без расширения. По окончании работы программы будет создано два файла: name.dot и name.fmt, где dot - текстовое описание графа, а fmt - формат, заданный опцией --format

=item B<-f|--functions f1,f2 ...>

=item B<-f|--functions f1 f2 ...>

=item B<-f|--functions f1 -f f2 ...>

Даёт возможность вывести не всю карту, а лишь ту её часть, что соответствует заданным именам функций f1,f2... и функциям, которые вызываются ими.

=item B<--[no-]priority>

Отмечает на карте очереди приоритетов. По умолчанию включено. Очереди приоритетов задаются в файле F<.graph.conf>

=item B<--[no-]done>

Отмечает на карте проверифицированные функции. По умолчанию включено. Список проверифицированных функций задаётся в файле F<.graph.conf>

=item B<-i|--[no-]issues>

Помечает на карте issues. Критерии, в соответствии с которыми необходимо помечать вершины, как и сами метки, задаются в файле F<.graph.conf>

=item B<-m|--[no-]mark-anyway>

Функции, которые явно входят в списки приоритетов помечаются на карте особым образом. Однако, если функция из очереди приоритетов вызывается одной из функций, у которой приоритет выше, то первая не получает специальной пометки. Данный флаг задаёт поведение, при котором функции из списка приоритетов помечаются особым образом всегда. По умолчанию выключено.

=item B<-v|--[no-]view>

После работы программы открывает в стандартной программе для просмотра изображений созданную карту.

=item B<-h|--help>

Выводит полное описание программы.

=back

=head1 DESCRIPTION

Успешность проведения верификации кода во многом зависит от чёткой организации и координации процесса работ. Данная программа создана с целью упрощения разработки спецификаций с точки зрения удобства восприятия и изучения структуры кода человеком и является вспомогательным средством для осуществления верификационного процесса. Необходимость его создания возникает из того, что исходные коды модуля ядра не фиксированы, и находятся в разработке, в том числе регулярно подвергаются адаптации под релизы новых версий ядра Linux. Инструмент позволяет вовремя отслеживать изменения, производить адаптацию спецификаций в соответствии с ними. Основное предназначение инструмента состоит в систематизации подхода к решению задачи верификации и стабилизации рабочего процесса.

Существует достаточно большое количество инструментов, позволяющих упростить программисту навигацию по исходному коду. Некоторые из этих инструментов, такие как B<doxygen> и B<cscope> умеют также строить графы вызовов. Однако данные инструменты некорректно работают с кодом модуля ядра. То есть кодом, который является частью большего проекта. С помощью них нельзя построить граф вызов только функций модуля, не включая в него функции ядра. Полный же граф лишь ещё более запутывал бы картину, потому как количество вершин и рёбер в нём не позволяло бы отобразить его разборчиво для человеческого глаза. Также, данные инструменты не имеют возможности вывести весь граф в целом единовременно, а только по частям.

Программа работает с препроцессированными исходными кодами(но имеет возможность автоматически вызвать препроцессор для необработанных исходных кодов), на первой стадии строит индекс всех функций в коде модуля, на второй анализирует вхождение имён функций из индекса в тела функций и строит граф, на третей задаёт дополнительные атрибуты вершинам графа(например, такие как цвет для разметки очередей приоритетов), на четвёртой выводит граф в формате dot. Для построения графического представления используется программа B<dot> из пакета B<graphviz>.

=head1 BUGS

Если в исходных кодах есть функции с одинаковым именем (например, static функции с одинаковым именем в разных файлах), то на карте они сольются в одну. Множества рёбер для них объединятся.

=cut


my @functions;
my $format = 'svg';
my $out = 'graph';
my $module_dir;
my $kernel_dir;
my $preprocessed;
my $cache = 0;
my $cache_dir = "$FindBin::Bin/.cache";
my $cache_file = 'graph_map.cache';
my $conf_file = "$FindBin::Bin/.graph.conf";
my $done = 1;
my $priority = 1;
my $issues = 0;
my $stat = 1;
my $mark_anyway = 0;
my $help = 0;
my $view = 0;
my $open_with = 'xdg-open';

GetOptions(
   'functions|f=s{1,}'       =>  \@functions,
   'format=s'                =>  \$format,
   'output|o=s'              =>  \$out,
   'preprocessed|p=s'        =>  \$preprocessed,
   'sources|s=s'             =>  \$module_dir,
   'kernel|k=s'              =>  \$kernel_dir,
   'cache!'                  =>  \$cache,
   'done!'                   =>  \$done,
   'priority!'               =>  \$priority,
   'issues|i!'               =>  \$issues,
   'mark-anyway|m!'          =>  \$mark_anyway,
   'view|v!'                 =>  \$view,
   'help|h'                  =>  \$help
) or pod2usage(1);

@functions = split(/,/,join(',',@functions));


pod2usage({-verbose => 2, -exitval => 0}) if $help;
unless ($preprocessed) {
   $module_dir //= $ENV{CURRENT_PROJECT} // '.';
   $kernel_dir //= autodetect_kernel_directory(dirs => ['..']);

   pod2usage({ -msg => "You should provide kernel directory with -k option.\n", -exitval => 2 }) unless defined $kernel_dir;
   pod2usage({ -msg => "$module_dir is not a directory.\n",        -exitval => 2 }) unless -d $module_dir;
   pod2usage({ -msg => "$kernel_dir is not a kernel directory.\n", -exitval => 2 }) unless check_kernel_dir($kernel_dir);
} else {
   pod2usage({ -msg => "$preprocessed file is not readable.\n",    -exitval => 2 }) unless -r $preprocessed;
   pod2usage({ -msg => "Either preprocessed flag or sources flag should be specified\n", -exitval => 2 }) if $module_dir;
}


$cache = 0 if $preprocessed;

if ($cache_dir) {
   mkdir($cache_dir) or
      die("Can't create directory $cache_dir: $!\n")
         unless -e $cache_dir;

   $cache_file = "$cache_dir/$cache_file";
}

$cache = 0 unless -r $cache_file;

my $conf;
if (-r $conf_file) {
   $conf = LoadFile($conf_file)
} else {
   die("Can't read config file.\n")
}


goto CACHE if $cache;


# read sources
my $source;
if ($preprocessed) {
   $source = read_file($preprocessed, scalar_ref => 1);
} else {
   $source = (preprocess_module_sources($kernel_dir, $module_dir, ["#define SPECIFICATION 1\n"]))[1];
}
adapt($$source, attributes => 1, comments => 1);

#funcs init
my %sources;
$sources{module}{function} = C::FunctionSet->parse($source, 'module');
my $graph = build_sources_graph(\%sources, human_readable => 1, reverse => 1);

#these are special kernel functions generated after preprocessing
$graph->delete_vertices( qw(__check_enabled __inittest) );

CACHE: if ($cache) {
   $graph = retrieve($cache_file)
} else {
   store($graph, $cache_file)
}


#1
$graph->set_vertex_attribute($_, shape => 'octagon')
   foreach $graph->successorless_vertices();

#2
my $stat_done = 0;
my @marked_as_done;

if ($done) {
   #sub label_done { "\N{BALLOT BOX WITH CHECK} " . join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   #sub label_done { join( '', map { $_ . "\N{U+0336}" } split '', $_[0] ) }
   sub label_done { state $mark = "\N{BALLOT BOX WITH CHECK} "; $mark . $_[0] }

   foreach (uniq @{ $conf->{done} }) {
      if ($graph->has_vertex($_)) {
         $graph->set_vertex_attribute($_, 'label', label_done($_));
         $graph->set_vertex_attribute($_, style   => 'dashed');
         $graph->set_vertex_attribute($_, done    => 1);
         $stat_done++;
         push @marked_as_done, $_;
      } else {
         warn "Done: there is no function: '$_'\n"
      }
   }

   #check @marked_as_done
   foreach($graph->all_successors(@marked_as_done)) {
      warn "Predecessor of '$_' is marked as done, but '$_' doesn't.\n"
         unless any($_, @marked_as_done);
   }
}


#3
my @stat_priority;
if ($priority) {
   while ( my ($i, $list) = each $conf->{priority}{lists} ) {
      my $color = $conf->{priority}{colors}{$list};
      my %stat = ( done => 0, remains => 0);

      foreach (uniq @$list) {
         if ($graph->has_vertex($_)) {

            unless ($graph->has_vertex_attribute($_, 'priority')) {
               unless ($graph->has_vertex_attribute($_, 'done')) {
                  $graph->set_vertex_attribute($_, style => 'filled' );
                  $graph->set_vertex_attribute($_, fillcolor => $color );
                  $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );
                  $stat{remains}++
               } else {
                  $stat{done}++
               }
               $graph->set_vertex_attribute($_, priority => $i + 1);
            } else {
               if ($mark_anyway) {
                  $graph->set_vertex_attribute($_, fillcolor => $color );
                  $graph->set_vertex_attribute($_, shape => 'tripleoctagon' );
               }
               my $lev = $graph->has_vertex_attribute($_, 'priority');
               warn "'$_' has been already marked as $lev priority level function\n";
               next
            }

            foreach ($graph->all_successors($_)) {
               unless ($graph->has_vertex_attribute($_, 'priority')) {
                  unless ($graph->has_vertex_attribute($_, 'done')) {
                     $graph->set_vertex_attribute($_, style => 'filled' );
                     $graph->set_vertex_attribute($_, fillcolor => $color );
                     $stat{remains}++
                  } else {
                     $stat{done}++
                  }
                  $graph->set_vertex_attribute($_, priority => $i + 1);
               }
            }
         } else {
            warn "Priority list: there is no such function '$_' in sources.\n"
         }
      }

      push @stat_priority, \%stat;
   }
}

#4
my %used_issues;
if ($issues) {
   my $mark = "\N{SALTIRE}";
   foreach (keys %{ $conf->{issues} }) {
      foreach my $v ($graph->vertices) {
         if ($graph->get_vertex_attribute($v, 'object')->code =~ m/$conf->{issues}{$_}{re}/) {
            $used_issues{$_} = undef;

            unless ($graph->has_vertex_attribute($v, 'done')) {
               unless ($graph->get_vertex_attribute($v, 'shape') eq 'record') {
                  $graph->set_vertex_attribute($v, shape => 'record');
                  $graph->set_vertex_attribute($v, style =>
                     $graph->get_vertex_attribute($v, 'style') . ',bold');
                  $graph->set_vertex_attribute($v, label => "$mark $v | $_");
               } else {
                  $graph->set_vertex_attribute($v, label =>
                     $graph->get_vertex_attribute($v, 'label') . " | $_")
               }
            } else {
               warn "Issue $_ in already done function '$v'\n"
            }
         }
      }
   }

   my @diff = difference([ keys %{ $conf->{issues} } ], [ keys %used_issues ]);
   if (@diff) {
      warn "Issues @diff is/are useless, since there is no vertices marked.\n"
   }
}

if ($stat) {
   say "\n--- Статистика ---";
   say "Общее количество функций: " . $graph->vertices;
   if ($priority) {
      say "Функции по уровням приоритета:";
      print map
         {
            state $i = 0;
            ++$i;
            my $t = $_->{done} + $_->{remains};
            "\t[$i] общее количество: $t \tсделано: $_->{done} \tосталось: $_->{remains}\n"
         } @stat_priority;

      my ($done, $remains) = (0, 0);
      foreach ($graph->vertices) {
         unless ($graph->has_vertex_attribute($_, 'priority')) {
            if ($graph->has_vertex_attribute($_, 'done')) {
               $done++;
            } else {
               $remains++;
            }
         }
      }
      my $total = $done + $remains;
      say "Не вошедших в очереди приоритетов: $total; из них сделано $done; осталось $remains";
   }
   say "Всего сделано: " . $stat_done if $done;
}

if (@functions) {
   my @e;
   foreach (@functions) {
      unless ($graph->has_vertex($_)) {
         warn "There is no such function: '$_'.\n"
      } else {
         push @e, $_
      }
   }

   if (@e) {
      $graph = get_successors_subgraph($graph, @e);

      say "Количество функций в подграфе в выбранном подграфе: " . $graph->vertices
         if $stat;
   } else {
      warn "--functions parameter will not be taken into account.\n"
   }
}


{
   local $SIG{__WARN__} = sub {};
   Graph::Writer::Dot->new()->write_graph($graph, "$out.dot")
}

if ($priority || $issues) {
   my @legenda;

   if ($issues) {
      push @legenda, qq(  subgraph "cluster_issues_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Issues legenda";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      my $edges = join(' -> ', map { "\"$_\"" } keys %used_issues);
      push @legenda, qq(    $edges [ style = "invis" ];\n);
      foreach (keys %used_issues) {
         push @legenda, qq(    "$_" [label = "$_: $conf->{issues}{$_}{description}", fillcolor = "white"];\n);
      }
      push @legenda, qq(  }\n);
   }

   if ($priority) {
      push @legenda, qq(  subgraph "cluster_priority_legenda" {\n);
      push @legenda, qq(    style = "filled";\n);
      push @legenda, qq(    color = "lightgrey";\n);
      push @legenda, qq(    label = "Priority levels";\n);
      push @legenda, qq(    node [shape = "box", style = "filled"];\n);
      push @legenda, qq(    "1" -> "2" -> "3" -> "4" -> "5" [ style = "invis" ];\n);
      my $colors = [ map { $conf->{priority}{colors}{$_} } @{ $conf->{priority}{lists} } ];
      while (my ($idx, $color) = each $colors) {
         ++$idx;
         push @legenda, qq(    "$idx" [fillcolor = "$color"];\n);
      }
      push @legenda, qq(  }\n);
   }

   my @dot = read_file("$out.dot", { binmode => ':utf8' });
   splice @dot, 2, 0, @legenda;
   write_file("$out.dot", { binmode => ':utf8' }, @dot);
}

say "\nFile $out.dot contains graph in dot format.";
say "File $out.${format} contains graph in ${format} format.";

if (which('dot')) {
   fork and exit;
   my $output = "${out}.${format}";
   system('dot', "-T${format}", "${out}.dot", "-o${output}");
   close(STDOUT);
   close(STDERR);

   if ($view) {
      if (which($open_with)) {
         exec('xdg-open', $output)
      } else {
         die("Can't find $open_with program to view the $output\n")
      }
   }
} else {
   die("Can't find dot program to create the source map.\n");
}

