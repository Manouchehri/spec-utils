#!/usr/bin/env perl

use warnings;
use strict;

use feature qw(say state);

use utf8::all;

use Pod::Usage;
use File::Spec::Functions qw(catfile catdir);
use Getopt::Long qw(:config gnu_compat no_bundling no_permute no_getopt_compat);
use YAML::XS qw(LoadFile);
use FindBin;

use lib::abs 'lib';

use Local::Config qw(find_config);
use Kernel::Common qw(check_kernel_dir autodetect_kernel_directory);
use App::Graph;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}


=encoding utf8

=pod

=head1 graph

graph - построить граф вызовов функций модуля ядра Linux

=head1 SYNOPSIS

 graph [options]
 Options:
  -m|--module dir          - директория с исходными кодами модуля
                             (default: CURRENT_PROJECT || ./)

  -k|--kernel dir          - директория с исходными кодами ядра
                             (default: CURRENT_KERNEL || ../)

  -p|--preprocessed name   - файл с препроцессированным кодом модуля

  --[no-]cache             - [не]использовать сохранённые результаты обработки
                             исходных кодов
                             (default: off)

  --format fmt             - формат карты
                             (default: svg)

  -o|--output name         - имя (без расширения) для карты и .dot файла
                             (default: graph)

  -f|--functions f1 -f f2 ...
  -f|--functions f1,f2,...
  -f|--functions f1 f2 ... - строить граф от функций f1 f2 ...

  -r|--[no-]reverse        - строить карту от указанных функций вверх

  --[no-]priority          - отмечает на карте очереди приоритетов
                             (default: on)
  --[no-]done              - отмечает на карте проверифицированные функции
                             (default: on)
  -i|--[no-]issues         - помечает на карте issues
                             (default: off)

  -a|--[no-]mark-anyway    - помечать функции из списка приоритетов в любом случае
                             (default: off)

  -v|--[no-]view           - открыть в стандартной программе для просмотра
                             изображений созданную карту
                             (default: off)
  -h|--help                - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-m|--module dir>

Указание на директорию, где расположены исходные коды модуля ядра. По умолчанию директория берётся из переменной окружения I<CURRENT_SOURCES> если она задана, иначе используется текущая директория. Данные исходные коды в дальнейшем будут препроцессированы с директивой C<#define SPECIFICATION>.

=item B<-k|--kernel dir>

Указание на директорию, где расположены исходные коды ядра Linux. По умолчанию директория берётся из переменной окружения I<CURRENT_KERNEL> если она задана, иначе используется родительская директория текущей.

=item B<-p|--preprocessed name>

Указание на файл, в котором содержатся уже препроцессированные исходные коды. Данная опция не может указываться одновременно с опцией --sources. Так как они обе задают входные данные. Отличие состоит в том, что --sources указывает на директорию, где хранится множество непрепроцессированных файлов(которые соответствующим образом будут обработаны), а --preprocessed указывает на файл с кодом, где содержится код на чистом C.

=item B<--[no-]cache>

Программа при первом запуске кэширует результаты обработки исходного кода модуля ядра (файл F<.cache/graph_map.cache>). При последующих запусках используются сохранённые результаты. Чтобы программа не использовала их необходимо задать опцию --no-cache. В таком случае кэш будет обновлён.

=item B<--format fmt>

Формат графической карты. Поддерживаемые форматы (ps svg svgz fig png gif imap cmapx) соответствуют таковым для программы dot. По умолчанию используется формат svg.

=item B<-o|--output name>

Задаёт имя выходного файла без расширения. По окончании работы программы будет создано два файла: name.dot и name.fmt, где dot - текстовое описание графа, а fmt - формат, заданный опцией --format

=item B<-f|--functions f1,f2 ...>

=item B<-f|--functions f1 f2 ...>

=item B<-f|--functions f1 -f f2 ...>

Даёт возможность вывести не всю карту, а лишь ту её часть, что соответствует заданным именам функций f1,f2... и функциям, которые вызываются ими.

=item B<-r|--[no-]reverse>

Строить карту вверх от указанных функций. На карте будут отображены те функции, которые зависят от указанных. Опция имеет смысл только в том случае, когда используется опция --functions

=item B<--[no-]priority>

Отмечает на карте очереди приоритетов. По умолчанию включено. Очереди приоритетов задаются в файле F<.graph.conf>

=item B<--[no-]done>

Отмечает на карте проверифицированные функции. По умолчанию включено. Список проверифицированных функций задаётся в файле F<.graph.conf>

=item B<-i|--[no-]issues>

Помечает на карте issues. Критерии, в соответствии с которыми необходимо помечать вершины, как и сами метки, задаются в файле F<.graph.conf>

=item B<-a|--[no-]mark-anyway>

Функции, которые явно входят в списки приоритетов помечаются на карте особым образом. Однако, если функция из очереди приоритетов вызывается одной из функций, у которой приоритет выше, то первая не получает специальной пометки. Данный флаг задаёт поведение, при котором функции из списка приоритетов помечаются особым образом всегда. По умолчанию выключено.

=item B<-v|--[no-]view>

После работы программы открывает в стандартной программе для просмотра изображений созданную карту.

=item B<-h|--help>

Выводит полное описание программы.

=back

=head1 DESCRIPTION

Успешность проведения верификации кода во многом зависит от чёткой организации и координации процесса работ. Данная программа создана с целью упрощения разработки спецификаций с точки зрения удобства восприятия и изучения структуры кода человеком и является вспомогательным средством для осуществления верификационного процесса. Необходимость его создания возникает из того, что исходные коды модуля ядра не фиксированы, и находятся в разработке, в том числе регулярно подвергаются адаптации под релизы новых версий ядра Linux. Инструмент позволяет вовремя отслеживать изменения, производить адаптацию спецификаций в соответствии с ними. Основное предназначение инструмента состоит в систематизации подхода к решению задачи верификации и стабилизации рабочего процесса.

Существует достаточно большое количество инструментов, позволяющих упростить программисту навигацию по исходному коду. Некоторые из этих инструментов, такие как B<doxygen> и B<cscope> умеют также строить графы вызовов. Однако данные инструменты некорректно работают с кодом модуля ядра. То есть кодом, который является частью большего проекта. С помощью них нельзя построить граф вызов только функций модуля, не включая в него функции ядра. Полный же граф лишь ещё более запутывал бы картину, потому как количество вершин и рёбер в нём не позволяло бы отобразить его разборчиво для человеческого глаза. Также, данные инструменты не имеют возможности вывести весь граф в целом единовременно, а только по частям.

Программа работает с препроцессированными исходными кодами(но имеет возможность автоматически вызвать препроцессор для необработанных исходных кодов), на первой стадии строит индекс всех функций в коде модуля, на второй анализирует вхождение имён функций из индекса в тела функций и строит граф, на третей задаёт дополнительные атрибуты вершинам графа(например, такие как цвет для разметки очередей приоритетов), на четвёртой выводит граф в формате dot. Для построения графического представления используется программа B<dot> из пакета B<graphviz>.

=head1 BUGS

Если в исходных кодах есть функции с одинаковым именем (например, static функции с одинаковым именем в разных файлах), то на карте они сольются в одну. Множества рёбер для них объединятся.

=cut


my %opts;
$opts{functions} = [];
$opts{format} = 'svg';
$opts{out} = 'graph';
$opts{cache} = 0;
my @cache_dir = (catdir($ENV{HOME}, '.cache', 'graph'), catdir($FindBin::Bin, '.cache'));
$opts{cache_file} = 'graph_map.cache';
$opts{done} = 1;
$opts{priority} = 1;
$opts{issues} = 0;
$opts{stat} = 1;
$opts{mark_anyway} = 0;
$opts{view} = 0;
$opts{open_with} = 'xdg-open';

$opts{async} = 1;
$opts{keep_dot} = 1;
$opts{reverse} = 0;

my $help = 0;

GetOptions(
   'functions|f=s{1,}'       =>  \@{ $opts{functions} },
   'format=s'                =>  \$opts{format},
   'output|o=s'              =>  \$opts{out},
   'preprocessed|p=s'        =>  \$opts{preprocessed},
   'module|m=s'              =>  \$opts{module_dir},
   'kernel|k=s'              =>  \$opts{kernel_dir},
   'cache!'                  =>  \$opts{cache},
   'done!'                   =>  \$opts{done},
   'priority!'               =>  \$opts{priority},
   'issues|i!'               =>  \$opts{issues},
   'mark-anyway|a!'          =>  \$opts{mark_anyway},
   'view|v!'                 =>  \$opts{view},
   'reverse|r!'              =>  \$opts{reverse},
   'help|h'                  =>  \$help
) or pod2usage(1);

$opts{functions} = [ split(/,/,join(',', @{ $opts{functions} })) ];


pod2usage({-verbose => 2, -exitval => 0}) if $help;
unless ($opts{preprocessed}) {
   $opts{module_dir} //= $ENV{CURRENT_PROJECT} // '.';
   $opts{kernel_dir} //= autodetect_kernel_directory(dirs => ['..']);

   pod2usage({ -msg => "You should provide kernel directory with -k option.\n", -exitval => 2 }) unless defined $opts{kernel_dir};
   pod2usage({ -msg => "$opts{module_dir} is not a directory.\n",        -exitval => 2 }) unless -d $opts{module_dir};
   pod2usage({ -msg => "$opts{kernel_dir} is not a kernel directory.\n", -exitval => 2 }) unless check_kernel_dir($opts{kernel_dir});
} else {
   pod2usage({ -msg => "$opts{preprocessed} file is not readable.\n",    -exitval => 2 }) unless -r $opts{preprocessed};
   pod2usage({ -msg => "Either preprocessed flag or sources flag should be specified\n", -exitval => 2 }) if $opts{module_dir};
}

if (!@{$opts{functions}} && $opts{reverse}) {
   warn "There is not point in using reverse option without --functions\n"
}

### KERNEL DIRECTORY: $opts{kernel_dir}
### MODULE DIRECTORY: $opts{module_dir}

$opts{cache} = 0 if $opts{preprocessed};

{
   my $c = 0;
   foreach (@cache_dir) {
      unless (mkdir($_)) {
         unless (-e $_) {
            warn("Can't create directory $_: $!\n");
            next
         }
      }

      $opts{cache_file} = catfile $_, $opts{cache_file};
      $c = 1;
      last
   }
   die "Can't create cache directory.\n"
      unless $c
}

### CACHE FILE: $opts{cache_file}
$opts{cache} = 0 unless -r $opts{cache_file};

my $conf;
if (defined ($conf = find_config())) {
   ### CONFIG FILE: $conf
   $opts{conf} = LoadFile($conf)
}
die("Can't read config file.\n")
   unless $opts{conf};


run(\%opts); # Can die.

say '';
say "File $opts{out}.dot contains graph in dot format.";
say "File $opts{out}.$opts{format} contains graph in $opts{format} format.";



