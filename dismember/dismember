#!/usr/bin/env perl

use warnings;
use strict;

use feature qw(say);
use re '/aa';

use Graph::Directed;
use Graph::Reader::Dot;

use Data::Alias qw(alias deref);
use Getopt::Long qw(:config gnu_getopt);
use Scalar::Util qw(blessed);
use Storable;

use FindBin;
use lib "$FindBin::Bin/../lib/";

use Local::List::Utils qw(difference any);
use Local::String::Utils qw(normalize);
use Local::Kernel::Module qw(parse_sources);
use Local::Kernel::Module::Graph qw(
   build_sources_graph
   get_predecessors_subgraph
   output_sources_graph
);

use C::Macro;
use C::MacroSet;
use C::TypedefSet;
use C::StructureSet;
use C::EnumSet;
use C::FunctionSet;
use C::DeclarationSet;
use C::GlobalSet;


my $function;
my $parsec_dir = $ENV{PARSEC_SOURCES} // '.';
my $kernel_dir = $ENV{PARSEC_KERNEL_SOURCES} // '.';
my $use_cache = 1;
my $output_dir = "$FindBin::Bin/result";
my $cache_dir  = "$FindBin::Bin/.cache";
my $cache_file = "graph.cache";

my $single_file = 0;

GetOptions(
   'function|f=s'          =>  \$function,
   'parsec|d=s'            =>  \$parsec_dir,
   'kernel|k=s'            =>  \$kernel_dir,
   'cache|c!'              =>  \$use_cache,
   'single|s!'             =>  \$single_file
) or die "Incorrect usage!\n";

die("You should provide function name.\n") if !$function;
die("$parsec_dir is not a directory.\n") if ! -d $parsec_dir;
die("$kernel_dir is not a kernel directory.\n") if ! -f "$kernel_dir/Kbuild";

sub create_directory
{
   mkdir($_[0]) or
      die("Can't create directory $_[0]: $!\n")
         if $_[0] && (! -e $_[0])
}

create_directory $output_dir;

if ($cache_dir) {
   create_directory $cache_dir;
   $cache_file = "$cache_dir/$cache_file";
}


$use_cache = 0 if ! -r $cache_file;
say "USE_CACHE: $use_cache";
goto CACHED_GRAPH if $use_cache;


my %sources = parse_sources($kernel_dir, $parsec_dir, ["#define SPECIFICATION 1\n"]);

my $g = build_sources_graph(\%sources);
$g->set_graph_attribute('comments', $sources{comments});
$g->set_graph_attribute('index', $sources{module}{function}->index);


CACHED_GRAPH:
if ($use_cache) {
   $g = retrieve($cache_file)
} else {
   store($g, $cache_file)
}


{
   my $id = $g->get_graph_attribute('index')->{$function};
   die("There is no function $function in module\n")
      if ! $id;

   $output_dir = "$output_dir/$function";
   create_directory $output_dir;

   say "DELETE UNNEEDED VERTICES";
   $g = get_predecessors_subgraph($g, $id);
}


#resolve cycles
while ($g->has_a_cycle) {
   my @path = $g->find_a_cycle;
   if (@path == 1) {
      $g->delete_edge($path[0], $path[0]);
      next
   }

   my $o1 = $g->get_vertex_attribute($path[0], 'object');
   my $o2 = $g->get_vertex_attribute($path[1], 'object');

   my $t1 = blessed($o1);
   my $t2 = blessed($o2);

   if ($t1 eq $t2) {
      say "$t1" . " " . $o1->name . " -> " . $o2->name;

      if ($t1 eq 'C::Function') {
         $o2->code =~ m/(\w.*?)\{/s;
         $o1->add_fw_decl(normalize($1) . ';');

         $g->delete_edge($path[0], $path[1])
      } elsif ($t1 eq 'C::Structure') {
         $g->delete_edge($path[0], $path[1])
      } elsif ($t1 eq 'C::Macro') {
         $g->delete_edge($path[0], $path[1])
      } elsif ($t1 eq 'C::Typedef') {
         $g->delete_edge($path[0], $path[1])
      } else {
         say "@path";
         exit;
      }
   } else {
      say "$t1" . " " . $o1->name . " -> " . "$t2" . " " . $o2->name;

      if ($t1 eq 'C::Typedef' && $t2 eq 'C::Structure') {
         $g->delete_edge($path[1], $path[0]) ; # FIXME: Is it right?
      } elsif ($t1 eq 'C::Structure' && $t2 eq 'C::Typedef') {
         $g->delete_edge($path[0], $path[1]);
      } else {
         say "ERROR: @path";
         exit;
      }

   }
}

output_sources_graph($g, $output_dir, $single_file);

