#!/usr/bin/env perl

use warnings;
use strict;

use feature qw/switch say/;
no if $] >= 5.018, warnings => "experimental::smartmatch";
use re '/aa';

use Pod::Usage;
use List::Util qw/any/;
use Getopt::Long qw(:config gnu_compat no_getopt_compat pass_through);
use File::Spec::Functions qw(catfile catdir);
use File::Which;
use Storable;
use POSIX qw/setsid/;
use Module::Loader;
use Try::Tiny;

use FindBin;
use lib::abs 'lib';

use Local::Config qw(find_config);
use Local::Terminal qw(window_size);
use Kernel::Common qw(check_kernel_dir autodetect_kernel_directory);
use Kernel::Module qw(parse_sources);
use Kernel::Module::Graph qw(
   build_sources_graph
   get_predecessors_subgraph
   output_sources_graph
);

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

=encoding utf8

=pod

=head1 dismember

dismember - программа для выборки из общего набора исходных кодов ядра и модуля ядра минимального объёма кода для конкретной функции с зависимостями, достаточного для компиляции в объектный файл

=head1 SYNOPSIS

 dismember [options]

 Options:
  -k|--kernel dir      - директория с исходными кодами ядра
  -m|--module dir      - директория с исходными кодами модуля

  -f|--functions f1 -f f2 ...
  -f|--functions f1,f2,...
  -f|--functions f1 f2 ...    - построить выборки для функций f1,f2,...
  -a|--all                    - построить выборки для всех функций модуля ядра
  -s|--single                 - поместить все зависимости функции -f в единый файл
  -r|--remove-fields          - адаптивно убрать неиспользуемые поля из enum

  -c|--cache num - три уровня кэша:
                      0 - отсутствует,
                      1 - ядро не менялось,
                      2 - ядро и модуль ядра не менялись
  -e|--editor    - по окончании работы программы запустить редактор (EDITOR)

  -h|--help    - выводит полное описание программы

=head1 OPTIONS

=over 8

=item B<-m|--module dir>

Указание на директорию, где расположены исходные коды модуля ядра. По умолчанию директория берётся из переменной окружения I<CURRENT_SOURCES> если она задана, иначе используется текущая директория. Данные исходные коды в дальнейшем будут препроцессированы с директивой C<#define SPECIFICATION>.

=item B<-k|--kernel dir>

Указание на директорию, где расположены исходные коды ядра Linux. По умолчанию директория берётся из переменной окружения I<CURRENT_KERNEL> если она задана.

=item B<-f|--functions f1,f2 ...>

=item B<-f|--functions f1 f2 ...>

=item B<-f|--functions f1 -f f2 ...>

Строить выборку для функций модуля ядра f1,f2,... Обязательная опция. Допускает несколько функций в качестве аргумента. Программа обрабатывает каждую функцию из списка аргументов так, как если бы она последовательно запускалась на каждой функции отдельно.

=item B<-a|--all>

Если флаг all включён, программа строит выборку для всех функций из модуля ядра. В таком случае опция --functions не обязательна. Флаг all необходим, главным образом, для целей тестирования.

=item B<-s|--single>

Результирующий редуцированный набор исходных кодов размещается в нескольких файлах. Флаг --single убирает это разделение по файлам и выводит всё в один файл module.c

=item B<-r|--remove-fields>

Убрать неиспользуемые константы из определений enum. Значения остальных изменяются так, чтобы соответствовать оригинальному определению.

=item B<-c|cache num>

Опция указывает кэш какого уровня использовать. По умолчанию кэширование отключено и исходные коды модуля и ядра каждый раз анализируются заново. Если выполняется разбор исходных кодов, кэшированная версия не используется, то результаты анализа сериализуются и сохраняются для возможного последующего использования в качестве кэша. Уровни num: 0 - кэш не используется; 1 - используется кэш, связанный с исходными кодами ядра (в исходных кодах модуля не должны меняться подключаемые заголовки, исходный код ядра не должен меняться, в обратном случае будет наблюдаться расхождение между результатом работы программы с кэшированием и без кэширования); 2 - используется результаты кэширования как разбора исходных кодов ядра, так и исходных кодов модуля ядра (код ядра, код модуля ядра должны оставаться неизменными с прошлого запуска программы)

=item B<-e|editor>

Запустить редактор по окончании работы программы. Открываются файлы module.c для всех функций опции --functions. Используется редактор из переменной окружения EDITOR.

=item B<-h|--help>

Выводит полное описание программы.

=back

=head1 DESCRIPTION

В качестве входных данных программа получает наборы исходных кодов ядра Linux и модуля ядра Linux (для корректной работы версии должны соответствовать друг другу, модуль должен собираться под данное ядро), через аргументы комадной строки указывается одна из функций модуля ядра. В процессе работы программа осуществляет препроцессинг и разбор исходных кодов. Строится ориентированный граф зависимостей функций, структур и т.д. После того как граф построен, он урезается до собственного подграфа, построенного от указанной функции. На следующей стадии осуществляется вывод вершин графа с определениями из исходных кодов структур, функций и т.д. в детерминированном порядке в четыре файла(один, если указана опция --single): extern.h(декларации функций ядра)  kernel.h(определения из ядра)  module.c(функции из модуля ядра)  module.h (определения структур, макросы и т.д. из модуля)

=cut


my @functions;
my $all_flag = 0;

#cache options
my $cache = 0;
my @cache_dir  = (catdir($ENV{HOME}, '.cache', 'dismember'), catdir($FindBin::Bin, '.cache'));
my @cache_file = (undef, 'kernel.cache', 'kernel_module.cache');

my %config;
$config{single_file}       = 0;
$config{remove_fields}     = 0;
$config{module_dir}        = $ENV{CURRENT_PROJECT} // '.';
$config{kernel_dir}        = undef;
$config{output_dir}        = catdir $FindBin::Bin, 'result';
$config{editor}            = 0;
$config{plugins}           = [];

if (defined (my $conf = find_config())) {
   ### CONFIG FILE: $conf
   open(my $conf, '<', $conf);
   foreach (<$conf>) {
      chomp;
      next if m/\A\h*+#?\h*+\Z/;

      if (m/(\w++)\h*+=\h*+(?|"([^"]++)"|'([^']++)'|(\S++))/) {
         if (exists $config{$1}) {
            if (ref $config{$1} eq 'ARRAY') {
               push @{$config{$1}}, $2
            } else {
               $config{$1} = $2
            }
         } else {
            warn "Unknown configuration option '$1'\n"
         }
      } else {
         warn "Wrong config format in line '$conf'\n"
      }
   }
   close($conf);
}


my $help = 0;

GetOptions(
   'all|a!'                =>  \$all_flag,
   'functions|f=s{1,}'     =>  \@functions,
   'module|m=s'            =>  \$config{module_dir},
   'kernel|k=s'            =>  \$config{kernel_dir},
   'cache|c:2'             =>  \$cache,
   'single|s!'             =>  \$config{single_file},
   'remove-fields|r!'      =>  \$config{remove_fields},
   'editor|e!'             =>  \$config{editor},
   'load-plugins=s@'       =>  \$config{plugins},
   'help|h'                =>  \$help
) or pod2usage(1);
@functions = split(/,/, join(',', @functions));
$config{functions} = \@functions;
$config{plugins} = [ split(/,/, join(',', @{$config{plugins}})) ];

pod2usage({-verbose => 2, -exitval => 0})
    if $help;

$config{kernel_dir} //= autodetect_kernel_directory();

pod2usage({ -msg => "You should provide at least one function name.\n", -exitval => 2 })
    if !@functions && !$all_flag;
pod2usage({ -msg => "$config{module_dir} is not a directory.\n", -exitval => 2 })
    unless -d $config{module_dir};
pod2usage({ -msg => "You should provide proper kernel directory with --kernel option\n", -exitval => 2 })
    unless check_kernel_dir($config{kernel_dir});

### KERNEL DIRECTORY: $config{kernel_dir}
### MODULE DIRECTORY: $config{module_dir}

my @plugins;
my %level = (full_graph => 1, reduced_graph => 2, pre_output => 3);
if (@{$config{plugins}}) {
   my $loader  = Module::Loader->new(max_depth => 1);
   my %pmap = map {lc(substr($_, rindex($_, ':') + 1)), $_} $loader->search('App::Dismember::Plugin');
   foreach my $p (@{$config{plugins}}) {
      if (any {$p eq $_} keys %pmap) {
         ### LOADING PLUGIN: $p
         my $plugin = $pmap{$p};
         $loader->load($plugin);

         foreach (qw/priority level action process_options/) {
            unless (eval { $plugin->can($_) }) {
               die "plugin $p $plugin: doesn't have method '$_'\n"
            }
         }

         # process_options should be called first
         my $obj = $pmap{$p}->process_options(\%config, \@plugins);

         unless ($obj->priority >= 0 && $obj->priority < 100) {
            die "plugin $p: only priority levels 0..99 supported\n"
         }
         unless (exists $level{$obj->level}) {
            die "plugin $p: unknown level\n"
         }

         push @plugins, $obj;
      } else {
         die "There is no plugin: $p\n"
      }
   }
}


sub plugins_sort
{
   my $l = $level{$b->level} <=> $level{$a->level};
   unless ($l) {
      my $p = $a->priority <=> $b->priority;
      die "Can't use plugin " . (ref $a) . " and " . (ref $b) . " combined.\n"
         unless $p;
      $p
   } else {
      $l
   }
}

@plugins = sort plugins_sort @plugins;


sub create_directory
{
   unless (mkdir($_[0])) {
      unless (-e $_[0]) {
         warn("Can't create directory $_[0]: $!\n");
         return 1
      }
   }

   0
}

create_directory $config{output_dir};

{
   my $c = 0;
   foreach my $dir (@cache_dir) {
      unless (create_directory($dir)) {
         @cache_file = map { defined $_ ? catfile($dir, $_) : $_ } @cache_file;
         $c = 1;
         last
      }
   }
   die "Can't create directory for cache.\n"
      unless $c
}

$cache = 2 if $cache > 2;
$cache = 0 if $cache && ! -r $cache_file[$cache];

### CACHE OPTIONS:
###   use:   $cache
###   file:  @cache_file
goto CACHED_GRAPH
   if $cache == 2;

### PARSING SOURCES...
my %sources = parse_sources($config{kernel_dir}, $config{module_dir}, ["#define SPECIFICATION 1\n"], !$cache);

### BUILDING SOURCES GRAPH...
my $g = build_sources_graph(\%sources, {cache => {use => $cache, file => $cache_file[1]}});
$g->set_graph_attribute('comments', $sources{comments});
$g->set_graph_attribute('index', $sources{module}{function}->index);


CACHED_GRAPH:
if ($cache == 2) {
   $g = retrieve($cache_file[2])
} else {
   store($g, $cache_file[2])
}

my $indx = $g->get_graph_attribute('index');

if ($all_flag) {
   @functions = keys %$indx # TODO: sorting
}

print "\n";

sub call_plugins
{
   my %opts = (level => $_[0], graph => $_[1], index => $indx, config => \%config);

   foreach (grep {$_->level eq $_[0]} @plugins) {
      try {
         $_->action(\%opts)
      } catch {
         when (/^FAIL:/) { die $_ };
         default { warn "Plugin $_ fails at level $_[0].\n" }
      };
   }
}

call_plugins 'full_graph', $g;

{
   my $total = @functions;
   my $i = 1;
   my (undef, $col) = window_size();
   my $msg = "GENERATING SUBGRAPH FOR FUNCTIONS: ";
   my $reserved_colons = length($msg) + length($total) + 3;

   # Arguments check
   @functions = grep {
         if (exists $indx->{$_}) { 1 }
         else { warn "Function $_ doesn't exist in module.\n"; 0 }
      } @functions;

   foreach my $function (@functions) {
      my $id = $indx->{$function};

      my $fd = catdir $config{output_dir}, $function;
      create_directory $fd;

      my $spaces = $col - $reserved_colons - length($function) - length($i);
      print $msg . $function . ' ' x $spaces . "[" . $i++ . "/$total]\n";
      my $g2 = get_predecessors_subgraph($g, $id);

      call_plugins 'reduced_graph', $g2;

      output_sources_graph($g2, $fd, $config{single_file}, $config{remove_fields});
      print "OUTPUT: " . ($config{single_file} ? catfile($fd, 'module.c') : $fd) . "\n\n";
   }
}

if ($config{editor}) {
   if (which($ENV{EDITOR})) {
      my @exec = ($ENV{EDITOR});
      foreach (@functions) {
         push @exec, catfile($config{output_dir}, $_, 'module.c')
      }

      if ($#exec > 0) {
         my $pid = fork();
         die "can't fork: $!"
            unless defined $pid;
         if ($pid) {
            print "$pid\n";
            exit 0;
         }

         setsid();
         exec(@exec);
      } else {
         warn "EDITOR will not be started since there is no files to work with.\n"
      }
   } else {
      die "Can't find application from EDITOR env variable.\n"
   }
}

