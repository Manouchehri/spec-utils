#!/usr/bin/env perl

use warnings;
use strict;

use feature qw(say);
use re '/aa';

use Getopt::Long qw(:config gnu_compat no_bundling no_permute no_getopt_compat);
use File::Spec::Functions qw(catfile catdir);
use Storable;

use FindBin;
use lib::abs 'lib';

use Local::Terminal qw(window_size);
use Local::Kernel::Common qw(check_kernel_dir autodetect_kernel_directory);
use Local::Kernel::Module qw(parse_sources);
use Local::Kernel::Module::Graph qw(
   build_sources_graph
   get_predecessors_subgraph
   output_sources_graph
);

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

my @functions;
my $all_flag = 0;

#cache options
my $cache = 0;
my @cache_dir  = (catdir($ENV{HOME}, '.cache/dismember'), catdir($FindBin::Bin, '.cache'));
my @cache_file = (undef, 'kernel.cache', 'kernel_module.cache');

#config options
my @conf_file = (catfile($FindBin::Bin, '.dismember.conf'), catfile($ENV{HOME}, '.config/dismember/config'));

my %config;
$config{single_file}       = 0;
$config{size_t_workaround} = 0;
$config{remove_fields}     = 0;
$config{module_dir}        = $ENV{CURRENT_PROJECT} // '.';
$config{kernel_dir}        = undef;
$config{output_dir}        = catdir $FindBin::Bin, 'result';

foreach (@conf_file) {
   if (-r $_) {
      ### CONFIG FILE: $_
      open(my $conf, '<', $_);
      foreach (<$conf>) {
         next if m/\A\h*+#?\h*+\Z/;
         if (m/(\w++)\h*+=\h*+(?|"([^"]++)"|'([^']++)'|(\S++))/) {
            if (exists $config{$1}) {
               $config{$1} = $2
            } else {
               warn "Unknown configuration option '$1'\n"
            }
         } else {
            warn "Wrong config format in line '$_'\n"
         }
      }
      close($conf);
      last
   }
}

GetOptions(
   'all|a!'                =>  \$all_flag,
   'functions|f=s{1,}'     =>  \@functions,
   'module|m=s'            =>  \$config{module_dir},
   'kernel|k=s'            =>  \$config{kernel_dir},
   'cache|c:2'             =>  \$cache,
   'single|s!'             =>  \$config{single_file},
   'remove-fields|r!'      =>  \$config{remove_fields},
   'size_t|workaround|w!'  =>  \$config{size_t_workaround}
) or die "Incorrect usage!\n";

@functions = split(/,/,join(',',@functions));

$config{kernel_dir} //= autodetect_kernel_directory();

die("You should provide at least one function name.\n") if !@functions && !$all_flag;
die("$config{module_dir} is not a directory.\n") unless -d $config{module_dir};
die("You should provide proper kernel directory with --kernel option\n") unless check_kernel_dir($config{kernel_dir});

### KERNEL DIRECTORY: $config{kernel_dir}
### MODULE DIRECTORY: $config{module_dir}

sub create_directory
{
   unless (mkdir($_[0])) {
      unless (-e $_[0]) {
         warn("Can't create directory $_[0]: $!\n");
         return 1
      }
   }

   0
}

create_directory $config{output_dir};

{
   my $c = 0;
   foreach my $dir (@cache_dir) {
      unless (create_directory($dir)) {
         @cache_file = map { defined $_ ? catfile($dir, $_) : $_ } @cache_file;
         $c = 1;
         last
      }
   }
   die "Can't create directory for cache.\n"
      unless $c
}

$cache = 2 if $cache > 2;
$cache = 0 if $cache && ! -r $cache_file[$cache];

### CACHE OPTIONS:
###   use:   $cache
###   file:  @cache_file
goto CACHED_GRAPH
   if $cache == 2;

### PARSING SOURCES...
my %sources = parse_sources($config{kernel_dir}, $config{module_dir}, ["#define SPECIFICATION 1\n"], !$cache);

### BUILDING SOURCES GRAPH...
my $g = build_sources_graph(\%sources, {cache => {use => $cache, file => $cache_file[1]}});
$g->set_graph_attribute('comments', $sources{comments});
$g->set_graph_attribute('index', $sources{module}{function}->index);


CACHED_GRAPH:
if ($cache == 2) {
   $g = retrieve($cache_file[2])
} else {
   store($g, $cache_file[2])
}

if ($config{size_t_workaround}) {
   foreach($g->vertices) {
      if ($g->get_vertex_attribute($_, 'object')->name eq 'size_t') {
         $g->delete_vertex($_);
         last
      }
   }
}

my $indx = $g->get_graph_attribute('index');

if ($all_flag) {
   @functions = keys $indx
}

print "\n";

{
   my $total = @functions;
   my $i = 1;
   my (undef, $col) = window_size();
   my $msg = "GENERATING SUBGRAPH FOR FUNCTION: ";
   my $reserved_colons = length($msg) + length($total) + 3;
   foreach my $function (@functions) {
      unless (exists $indx->{$function}) {
         warn "Function $function doesn't exist in module.\n\n";
         ++$i;
         next
      }
      my $id = $indx->{$function};

      my $fd = catfile $config{output_dir}, $function;
      create_directory $fd;

      my $spaces = $col - $reserved_colons - length($function) - length($i);
      print $msg . $function . ' ' x $spaces . "[" . $i++ . "/$total]\n";
      my $g2 = get_predecessors_subgraph($g, $id);

      output_sources_graph($g2, $fd, $config{single_file}, $config{remove_fields});
      print "OUTPUT: " . ($config{single_file} ? catfile($fd, 'module.c') : $fd) . "\n\n";
   }
}
