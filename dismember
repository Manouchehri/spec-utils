#!/usr/bin/env perl

use warnings;
use strict;

use feature qw(say);
use re '/aa';

use Graph::Directed;
use Graph::Reader::Dot;

use Data::Alias qw(alias deref);
use Getopt::Long qw(:config gnu_compat no_bundling no_permute no_getopt_compat);
use Scalar::Util qw(blessed);
use File::Spec::Functions qw(catfile);
use Storable;

use FindBin;
use lib catfile $FindBin::Bin, 'lib';

use Local::List::Utils qw(difference any);
use Local::String::Utils qw(normalize);
use Local::Kernel::Common qw(check_kernel_dir autodetect_kernel_directory);
use Local::Kernel::Module qw(parse_sources);
use Local::Kernel::Module::Graph qw(
   build_sources_graph
   get_predecessors_subgraph
   output_sources_graph
);

use C::Entity;
use C::Macro;
use C::MacroSet;
use C::TypedefSet;
use C::StructureSet;
use C::EnumSet;
use C::FunctionSet;
use C::DeclarationSet;
use C::GlobalSet;

BEGIN {
   eval {
      require Smart::Comments;
      Smart::Comments->import();
   }
}

my @functions;
my $all_flag = 0;
my $module_dir = $ENV{CURRENT_PROJECT} // '.';
my $kernel_dir;

#cache options
my $use_cache = 0;
my $cache_level = 0;
my $output_dir = catfile $FindBin::Bin, 'result';
my $cache_dir  = catfile $FindBin::Bin, '.cache';
my @cache_file = qw/kernel.cache kernel_module.cache/;

my $single_file = 0;
my $size_t_workaround = 0;

GetOptions(
   'all|a!'                =>  \$all_flag,
   'functions|f=s{1,}'     =>  \@functions,
   'module|m=s'            =>  \$module_dir,
   'kernel|k=s'            =>  \$kernel_dir,
   'cache|c!'              =>  \$use_cache,
   'cache-level|cl|l=i'    =>  \$cache_level,
   'single|s!'             =>  \$single_file,
   'size_t|workaround|w!'  =>  \$size_t_workaround
) or die "Incorrect usage!\n";

@functions = split(/,/,join(',',@functions));

$kernel_dir //= autodetect_kernel_directory();

die("You should provide at least one function name.\n") if !@functions && !$all_flag;
die("$module_dir is not a directory.\n") unless -d $module_dir;
die("You should provide proper kernel directory with --kernel option\n") unless check_kernel_dir($kernel_dir);

### KERNEL DIRECTORY: $kernel_dir
### MODULE DIRECTORY: $module_dir

sub create_directory
{
   mkdir($_[0]) or
      die("Can't create directory $_[0]: $!\n")
         if $_[0] && (! -e $_[0])
}

create_directory $output_dir;

if ($cache_dir) {
   create_directory $cache_dir;
   @cache_file = map { catfile($cache_dir, $_) } @cache_file;
}

$cache_level = undef
   unless $use_cache;

$use_cache = 0, $cache_level = undef
   if $use_cache && ! -r $cache_file[$cache_level];

### CACHE OPTIONS:
###   use:   $use_cache
###   level: $cache_level
###   file:  @cache_file
goto CACHED_GRAPH
   if $use_cache && $cache_level == 1;

### PARSING SOURCES...
my %sources = parse_sources($kernel_dir, $module_dir, ["#define SPECIFICATION 1\n"], !$use_cache);

### BUILDING SOURCES GRAPH...
my $g = build_sources_graph(\%sources, {cache => {use => $use_cache, file => $cache_file[0]}});
$g->set_graph_attribute('comments', $sources{comments});
$g->set_graph_attribute('index', $sources{module}{function}->index);


CACHED_GRAPH:
if ($use_cache && $cache_level == 1) {
   $g = retrieve($cache_file[1])
} else {
   store($g, $cache_file[1])
}

if ($size_t_workaround) {
   foreach($g->vertices) {
      if ($g->get_vertex_attribute($_, 'object')->name eq 'size_t') {
         $g->delete_vertex($_);
         last
      }
   }
}

{
   my $indx = $g->get_graph_attribute('index');

   if ($all_flag) {
      @functions = keys $indx
   }

   foreach my $function (@functions) {
      my $id = $indx->{$function};

      my $fd = catfile $output_dir, $function;
      create_directory $fd;

      ### GENERATING SUBGRAPH FOR FUNCTION: $function
      my $g2 = get_predecessors_subgraph($g, $id);

      ### WRITING RESULTS TO DISK
      print
      "###   OUTPUT: " . ($single_file ? catfile($fd, 'module.c') : $fd) . "\n";
      output_sources_graph($g2, $fd, $single_file);
   }
}



